<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JPA 공부</title>
    <!-- code pretty print -->
    <link rel="stylesheet" href="./css/codePrettyPrint.css">
  </head>
  <body>
    <section id="intro">
      <header class="note_title">JPA</header>
      <ul>
        <li>JPA
          <pre>
            ● JPA (Java Persistence API) : Java에 대한 ORM 기술 표준
            ● 인터페이스 모음집
            ● JPA 인터페이스를 구현한 오픈소스 종류 : Hibernate, EclipseLink, DataNucleus
          </pre>
        </li>
        <li>JPA의 사용 이유
          <pre>
            ● SQL 중심이 아닌 객체 중심으로 개발
                ○ SQL 작성시 코드 반복의 감소
                ○ 모델링 문제 해결
            ● CRUD가 간단하다.
                (※ 특히 수정이 간단하다. => 객체를 변경하면 자동으로 Update Query 실행)
            ● 유지보수
                ○ 기존 : 필드 변경 시 관련 SQL 모두 수정
                ○ JPA 사용 : 필드만 추가 (※ 이유 : SQL은 JPA가 대신 처리해주기 때문)
            ● Object와 RDB 간의 패러다임 불일치 해결
            ● 최적화 기능
                ○ 캐싱 기능 : 1차 캐시와 동일성 보장
                ○ 버퍼링 기능 : 트랜잭션을 지원하는 쓰기 지연
                ○ 지연 로딩 : 객체가 실제로 사용될 때 로딩하는 전략
                ○ 즉시 로딩 : Join SQL로 한 번에 연관된 객체까지 미리 조회하는 전략
            ● 데이터 접근 추상화와 벤더 독립성
            ● 표준
          </pre>
        </li>
        <li>JPA 동작 과정
          <pre>
            ● 기본 구조
                ○ 애플리케이션과 JDBC 사이에서 동작
                ○ 개발자가 JPA 사용시 JPA 내부에서 JDBC API를 통해서 SQL을 호출하여 DataBase와 통신

            ● 저장 과정
                1. 개발자가 저장을 원하는 객체를 JPA에 전달
                2. JPA가 Entity를 분석
                3. JPA가 Insert SQL 생성
                4. JPA가 JDBC API를 사용하여 SQL을 DB에 전송

            ● 조회 과정
                1. 개발자가 조회를 원하는 객체의 PK 값을 JPA에 전달
                2. JPA가 Entity의 매핑 정보를 바탕으로 적절한 Selete SQL 생성
                3. JPA가 JDBC API를 사용하여 SQL을 DataBase에 전달
                4. DataBase가 JPA에게 결과를 전달
                5. JPA가 DataBase한테 전달받은 결과를 객체에 매핑하여 전달
          </pre>
        </li>
      </ul>
    </section>

    <section id="installAndConnnecting">
      <header class="note_title">설치 및 연결</header>
      <ul>
        <li>설치 및 연결
          <pre>
            ● pom.xml에 dependency 추가
              <pre class="prettyprint lang-xml">
                &lt;dependency>
                    &lt;groupId>org.springframework.boot&lt;/groupId>
                    &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId>
                &lt;/dependency>
              </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="JpaRepository">
      <header class="note_title">JPA - Repository</header>
      <ul>
        <li>Repository 제작법
          <pre>
            1. JPA의 Repository로 사용할 인터페이스를 만든다.
            2. 해당 인터페이스에 org.springframework.data.jpa.repository.JpaRepository를 import한다.
            3. JpaRepository 클래스를 JpaRepository&lt;Entity형식,ID형식>으로 상속받는다.
                    예시) public interface BookRepository extends JpaRepository&lt;BookEntity, Long>
          </pre>
        </li>
        <li>Repository 종류
          <pre>
            ● Repository&lt;T, ID>
            ● CrudRepository&lt;T, ID>
            ● PagingAndSortingRepository&lt;T, ID>
            ● JpaRepository&lt;T, ID>

            ※ T : Entity의 타입클래스, ID : Primary Key의 Type 
          </pre>
        </li>
        <li>Repository의 기본 메소드 형식
          <pre>
            ● find~ : 특정 조건을 만족하는 데이터를 가져오기
            ● save~ : 해당 테이블에 데이터를 저장하기
            ● delete~ : 특정 조건을 만족하는 데이터를 삭제
            ● flush() : 영속성 컨텍스트의 변경 내용을 DataBase에 동기화
            ● existsById(ID id) : id값을 통해 데이터 존재 여부 판단 (Boolean 값 리턴)
            ● count() : 해당 테이블의 전체 데이터 개수를 리턴 (long 값 리턴)
          </pre>
        </li>
        <li>@Query 어노테이션
          <pre>
            ● JPA의 자동 SQL 생성기능 대신에 직접 쿼리를 작성할수 있게 해주는 어노테이션
              기본 예시)
                <pre class="prettyprint lang-java">
                  @Query(value = "select * from user limit 1;", nativeQuery = true)
                  Map&lt;String, Object> findOneUser();
                </pre>

            ● 옵션
              ○ value : SQL 쿼리를 작성하는 옵션
              ○ nativeQuery : 해당 옵션이 추가되어있으면 DB에서 직접 쿼리문을 작성하듯이 작성할수 있게 해준다.

            ● 주의점
              ○ 호출하는 테이블명에 반드시 별칭을 추가해서 사용해야 한다.

            ● 데이터 치환
              ○ ? 사용 : ?1이나 ?2처럼 각각의 순서에 맞는 숫자를 붙여서 파라미터가 들어갈 순서대로 쿼리에 명시한다.
              ○ :파라미터명 : :name이나 :age처럼 필요한 파라미터명에 맞춰서 쿼리에 명시하면 된다.
                ※ 기존에는 @Param("name") String name처럼 파라미터에 어노테이션이 필요했다.
                ※ 현재는 파라미터명만 잘 맞춰주면 알아서 잘 치환된다. (Spring 4 이상 + Java 8 이상)
          </pre>
        </li>
        <li>JPA를 통한 페이징 처리
          <pre>
            ※ PagingAndSortingRepository 인터페이스의 구현 필요

            ● Page&lt;VO타입> 객체명 = repository객체.find~(new PageRequest(page, size));
                ○ page : 찾을 페이지, 시작값 : 0
                ○ size : 한 페이지의 사이즈, 기본값 : 20

            ● 컨트롤러에서 Pageable 변수 받기
                예시)
                  <pre class="prettyprint lang-java">
                    @GetMapping("/users")
                    public List&lt;User> findAllUser(Pageable pageable) { ... }   
                    //GET /users?page=3&size=10&sort=id,DESC
                  </pre>

            ● @PageableDefault (페이징을 위한 기본값 설정 어노테이션)
                예시)
                  <pre class="prettyprint lang-java">
                    @GetMapping("/users")
                    public List&lt;User> findAllUser(@PageableDefault(size=100, sort="id", direction = Sort.Direction.DESC) Pageable pageable) { ... } 
                  </pre>

            ● 페이징 기본값 설정법 - application.properties
                spring.data.web.pageable.default-page-size=페이지_크기
          </pre>
        </li>
        <li>쿼리 메소드란?
          <pre>
            ● 메서드 이름으로 우리가 원하는 기능을 수행할 쿼리가 자동으로 생성해줄수 있도록 일정 규칙에 맞게 이름을 정의하여 사용하는 메서드
          </pre>
        </li>
        <li>쿼리 메소드 - 실행문
          <pre>
            ● 데이터 검색 (가독성을 위해 나눠져있을 뿐 모두 결과가 같다.)
                ○ findBy~
                ○ readBy~
                ○ getBy~
                ○ queryBy~
                ○ searchBy~
                ○ streamBy~

            ● 존재 여부 확인
                ○ existsBy~
            
            ● 개수 확인
                ○ countBy~
            
            ● 데이터 삭제
                ○ deleteBy~
                ○ removeBy~

            ● 처음부터 n개의 데이터 가져오기
                ○ ~First(숫자)~
                ○ ~Top(숫자)~
            
            ● 중복 제거
                ○ ~Distinct~
          </pre>
        </li>
        <li>쿼리 메소드 - 조건문
          <pre>
            ● 조건 연결
                ○ ~And~
                ○ ~Or~

            ● 조건 부정
                ○ ~Not~
                ○ ~IsNot~

            ● 참/거짓 체크
                ○ True
                ○ IsTrue
                ○ NotFalse
                ○ IsNotFalse

            ● 날짜 비교
                ○ 이전
                    ○ ~Before
                    ○ ~IsBefore
                ○ 이후
                    ○ ~After
                    ○ ~IsAfter
            ● 수치 비교
                ○ 작다
                    ○ ~LessThan
                    ○ ~IsLessThan
                ○ 작거나 같다
                    ○ ~LessThanEqual
                    ○ ~IsLessThanEqual
                ○ 크다
                    ○ ~GreaterThan
                    ○ ~IsGreaterThan
                ○ 크거나 같다
                    ○ ~GreaterThanEqual
                    ○ ~IsGreaterThanEqual

            ● 범위
                ○ m에서 n사이에 포함
                    ○ ~Between
                    ○ ~IsBetween
                ○ m,n,o...중에 포함
                    ○ ~In
                    ○ ~IsIn

            ● 단어 포함
                ○ ~로 시작
                    ○ ~StartingWith
                    ○ ~IsStartingWith
                    ○ ~StartsWith
                ○ ~로 종료
                    ○ ~EndingWith
                    ○ ~IsEndingWith
                    ○ ~EndsWith
                ○ ~ 포함
                    ○ ~Like
                    ○ ~IsLike
                    ○ Containing
                    ○ IsContaining
                    ○ Contains

            ● Null 체크
                ○ Null
                ○ IsNull
                ○ NotNull
                ○ IsNotNull

            ● Empty 체크
                ○ Empty
                ○ IsEmpty
                ○ NotEmpty
                ○ IsNotEmpty
          </pre>
        </li>
        <li>쿼리 메소드 - 정렬하기
          <pre>
            ● 단순 정렬
                ○ ~OrderBy칼럼명
                ○ ~OrderBy칼럼명Asc
                ○ ~OrderBy칼럼명Desc
            
            ● 정렬 방식 추가
                예시)
                  <pre class="prettyprint lang-java">
                    //List&lt;User> findFirstByName(String name, Sort sort)
                    userRepository.findFirstByName("HongGilDong", Sort.by(Order.desc("id"), Order.asc("email")))
                  </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="jpaEntity">
      <header class="note_title">JPA - Entity</header>
      <ul>
        <li>Entity Class 기본 생성법
          <pre>
            1. JPA의 Entity로 사용할 클래스를 만든다.
            2. 해당 클래스에 javax.persistence.Entity를 import 하고 @Entity를 추가해준다.
            3. 필요한 필드들을 필요한 어노테이션을 추가하면서 생성해준다.
          </pre>
        </li>
        <li>Entity Class 관련 어노테이션
          <pre>
            ● @Entity : 해당 클래스를 Entity로 등록한다.
              ○ name 옵션 : JPA에서 사용할 엔티티 이름을 지정한다. 보통 생략한다.
                예시) name = "Member"
            ● @Table : 매핑시킬 테이블을 직접 지정해준다.
              ○ name 옵션 : 매핑시킬 테이블의 이름을 명시한다.
                예시) name = "user"
              ○ indexes 옵션
                예시) indexes = { @Index(columnList = "name")}
              ○ uniqueConstraints 옵션 :
                  (1)매핑될 테이블에서 자신이 명시한 칼럼에 Unique 제약조건을 추가한다.
                  (2) 보통 columnNames 속성은 name 속성과 같이 사용한다. //이유 : 제약조건명 랜덤생성
                  예시) uniqueConstraints = {@UniqueConstraint(columnNames = {"email"})})
            ● @MappedSuperclass : 해당 어노테이션을 명시한 클래스를 상속받는 Entity Class는 해당 슈퍼 클래스의 필드를 칼럼으로 사용한다. 

            ● @Id : 해당 필드가 Primary Key이란 것을 의미한다.
            ● @GeneratedValue : hibernate의 sequence를 통해서 자동 증가하는 값이다.
              ○ strategy 옵션 : persistence provider가 Entity의 기본키를 생성하는 방법 (기본값 : AUTO)
                ○ AUTO : persistence provider가 특정 데이터베이스에 맞게 자동 선택하는 방법
                ○ IDENTITY : 데이터베이스의 identity 컬럼을 이용하는 방법 (MySQL)
                ○ SEQUENCE : 데이터베이스의 시퀀스 컬럼을 이용하는 방법 (ORACLE)
                ○ TABLE : 유일성이 보장된 데이터베이스 테이블을 이용하는 방법 (모든 DataBase에서 사용), @TableGenerator 필요
                예시) strategy=GenerationType.IDENTITY
            ● @Column : 해당 필드에 옵션을 추가한다.
              ○ name 옵션 : 테이블에서 사용되는 실제 칼럼명을 의미한다. 보통은 필드명과 칼럼명을 맞춘다.
                예시) name="homeAddress"
              ○ nullable 옵션 : null 가능 여부
                예시) nullable=false //필수값임을 의미
              ○ length 옵션 : 최대 길이 설정, String 타입에만 사용
                예시) length=10
              ○ unique 옵션 : 해당 필드가 unique함을 의미
                예시) unique=true
              ○ insertable 옵션 : 해당 필드의 값을 추가가능한지에 대한 여부
                예시) insertable = false
              ○ updatable 옵션 : 해당 필드의 값을 변경가능한지에 대한 여부
                예시) updatable = false
              ○ columnDefinition 옵션 : 해당 필드의 자료형을 직접 명시한다.
                예시) columnDefinition = "datetime(6) default now(6) comment '생성시간'"

            ● @NonNUll : 해당 필드는 반드시 값이 존재해야 한다.
            ● @Enumerated : Enum 타입 매핑
              ○ @Enumerated(value = EnumType.PRDINAL) : enum의 순서를 데이터베이스에 저장
                ※ 순서 변경 여부때문에 사용하지 않는다.
              ○ @Enumerated(value = EnumType.STRING) : enum의 이름을 데이터베이스에 저장
            ● @Temporal : 날짜 타입 매핑
              ○ @Temporal(TemporalType.DATE) : DB의 date 타입과 매핑
              ○ @Temporal(TemporalType.TIME) : DB의 time 타입과 매핑
              ○ @Temporal(TemporalType.TIMESTAMP) : DB의 timestamp 타입과 매핑
              ※ Java 8의 LocalDate 사용시에는 생략가능한 어노테이션
            ● @Lob : DB에서 Varchar를 넘어서는 큰 내용을 넣고 싶은 경우에 사영하는 어노테이션
            ● @Transient : DB에 관계없이 메모리에서만 사용하고자 하는 필드에만 추가하는 어노테이션
                => 임시 보관 데이터용으로 사용하는 어노테이션
          </pre>
        </li>
        <li>Entity Listener란?
          <pre>
            ● Entity의 변화를 감지해서 같은 테이블이나 다른 테이블의 데이터를 조작하기 위한 이벤트 리스너
            ● @SpringBootApplication이 있는 Main Class에 @EnableJpaAuditing 어노테이션을 추가해서 사용한다.
          </pre>
        </li>
        <li>Entity Listener의 종류
          <pre>
            ● @PrePersist : insert가 실행되기 전에 작동
            ● @PostPersist : insert가 실행된 후에 작동

            ● @PreUpdate : update가 실행되기 전에 작동
            ● @PostUpdate : update가 실행된 후에 작동

            ● @PreRemove : delete가 실행되기 전에 작동
            ● @PostRemove : delete가 실행되기 전에 작동
            ● @PostLoad : select가 실행된 후에 작동
          </pre>
        </li>
        <li>Entity Listener 생성 및 적용법
          <pre>
            1. 별도의 listener용 패키지를 만든다.
            2. listener로 사용할 클래스를 만든다.
            3. 해당 클래스 안에 필요한 Entity Listener를 작성해준다.
            4. Entity Listener를 사용할 Entity Class에 가서 @EntityListeners(value = EntityListener클래스명.class)을 추가해준다.
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="relation">
      <header class="note_title">연관관계</header>
      <ul>
        <li>1 : 1 관계
          <pre>
            ● 단방향
              <pre class="prettyprint lang-java">
                @Entity
                public class User {
                    ...
                    @OneToOne
                    @JoinColumn(name = "참조하는_칼럼명")
                    private Address address; //참조하는 Entity Class
                }
              </pre>

            ● 양방향
              <pre class="prettyprint lang-java">
                @Entity
                public class User {
                    ...
                    @OneToOne
                    @JoinColumn(name = "id") //Address Class에 있는 id 필드를 외래키로 지정
                    private Address address; //참조하는 Entity Class
                }

                @Entity
                public class Address {
                    @Id
                    @Column(name = "userID")
                    String id;
                    ...
                    @OneToOne(mappedBy = "address")
                    private User user; //User Class에 있는 address 필드와 매핑
                }
              </pre>

            ※ optional = false 옵션을 추가하면 반드시 null을 허용하지 않는 상태로 지정한다.
          </pre>
        </li>
        <li>1 : N 관계
          <pre>
            ● @OneToMany
              ○ targetEntity : 관계를 맺을 Entity Class
              ○ cascade : 현 Entity의 변경에 대해 관계를 맺은 Entity도 변경할지에 대한 여부 (JPA 레이어 수준에서 처리)
                예시) cascade=CascadeType.[ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH]
              ○ fetch : 관계 Entity의 데이터 읽기 전략
                예시) fetch=FetchType.[EAGER, LAZY]
                  (1) EAGER : 관계된 Entity의 정보를 미리 읽어오기
                  (2) LAZY : 실제로 요청하는 순간 가져오기
              ○ mappedBy : 양방향 관계 설정시 관계의 주체가 되는 쪽에서 정의하는 속성
                예시) mappedBy = "boardPosts"
              ○ orphanRemoval : 관계 Entity에서 변경이 일어난 경우 DB 변경을 같이 할지에 대한 여부 (DB 레이어에서 처리)
                예시 : orphanRemoval = true //기본값 : false

            <pre class="prettyprint lang-java">
              @Entity
              public class Board {
                  ...
                  @OneToMany(fetch = FetchType.EAGER)
                  @JoinColumn(name = "boardId") //BoardPost Class에 있는 boardId 필드를 외래키로 지정
                  private List&lt;BoardPost&gt; boardPosts = new ArrayList&lt;&gt;();
              }
            </pre>
          </pre>
        </li>
        <li>N : 1 관계
          <pre>
            ● @ManyToOne
              ○ targetEntity : 관계를 맺을 Entity Class
              ○ cascade : 현 Entity의 변경에 대해 관계를 맺은 Entity도 변경할지에 대한 여부 (JPA 레이어 수준에서 처리)
                예시) cascade=CascadeType.[ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH]
              ○ fetch : 관계 Entity의 데이터 읽기 전략
                예시) fetch=FetchType.[EAGER, LAZY]
                  (1) EAGER : 관계된 Entity의 정보를 미리 읽어오기
                  (2) LAZY : 실제로 요청하는 순간 가져오기
              ○ optional : null 설정 여부
                예시) optional = "false" //기본값 : true

            <pre class="prettyprint lang-java">
              @Entity
              public class BoardPost {
                  ...
                  @ManyToOne
                  Board board;
              }
            </pre>
          </pre>
        </li>
        <li>M : N 관계
          <pre>
            ● @ManyToMany라는 전용 어노테이션이 존재하긴 하지만 실무에서는 사용되지 않는다.
            ● 미사용 이유
              (1) 매핑 정보만 넣는 것이 가능하다.
              (2) 추가 정보를 넣는 것 자체가 불가능하다.
              (3) 예상하지 못하는 쿼리들이 나갈 가능성이 있다.
              (4) 애초에 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
            ● 해결방법 : 두 테이블을 연결하기 위한 전용 엔티티를 만들어서 연결한다.
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="persistence">
      <header class="note_title">영속성</header>
      <ul>
        <li>영속성 (persistence)
          <pre>
            ● 영속성 : 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성
            ● 비슷한 예시 : 메모리에 대해 설명할 때 주로 자주 나오는 설명인 비휘발성
          </pre>
        </li>
        <li>영속성의 특징
          <pre>
            ● 파일 시스템, 관계형 테이터베이스 혹은 객체 데이터베이스 등을 활용하여 구현한다.
              => 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에
                 프로그램을 종료하면 모두 잃어버리게 된다.
          </pre>
        </li>
        <li>Entity Manager
          <pre>
            ● 엔티티를 관리하는 역할을 수행하는 클래스
            ● Entity Manager 내부에 있는 영속성 컨텍스트를 통해서 엔티티들을 관리한다.
            ● Entity Manager는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.
          </pre>
        </li>
        <li>영속성 컨텍스트
          <pre>
            ● 엔티티를 영구히 저장하는 환경
            ● 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할
            ● Entity Manager를 통해 엔티티를 저장하거나 조회하면 Entity Manager는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
            ● 어느 정도 논리적이거나 추상적인 개념이다.
            ● 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유할 수도 있다
          </pre>
        </li>
        <li>영속성 컨텍스트의 특징
          <pre>
            ● Entity Manager를 생성할 때 하나 만들어진다.
            ● Entity Manager를 통해서 영속성 컨텍스트에 접근하고 관리할 수 있다.
            ● 영속성 컨텍스트를 관리하는 모든 엔티티 매니저가 초기화 및 종료되지 않는한 엔티티를 영구히 저장한다.
          </pre>
        </li>
        <li>엔티티의 생명 주기
          <pre>
            ● 비영속 : 영속성 컨텍스트와 연관이 없는 상태
              ○ @Entity 어노테이션을 갖는 엔티티 인스턴스를 막 생성했을 때는 영속성 컨텍스트에서 관리하지 않는다.
              ○ EntityManager의 persist 메소드를 사용하여 영속 상태로 변경할 수 있다.
              <pre class="prettyprint lang-java">
                em.persist(someEntity);
              </pre>
            ● 영속 : 영속성 컨텍스트에서 관리 중인 상태
              ○ EntityManager를 통해 데이터를 영속성 컨텍스트에 저장하는 경우
              ○ 영속 상태일 때의 장점
                (1) 1차 캐시 :
                  find 호출 → 영속성 컨텍스트에 캐시된 데이터 탐색 → if(Data X) DB 접근 및 데이터 로드 후 1차 캐시 데이터에 저장 → 결과 반환
                (2) 동일성 보장 : JPA를 통해 불러온 데이터는 모두 캐시 데이터에 저장되기 때문에 같은 id를 가진 데이터는 같은 데이터
                (3) 트랜잭션 지원하는 쓰기 지연
                  ○ Transaction이 시작된 이후 JPA가 생성한 쿼리는 모두 쓰기 지연 저장소에 저장된다.
                  ○ commit이 수행되면 저장된 모든 쿼리를 실행한다.
                (4) 변경 감지
                  ○ JPA는 데이터를 저장하기 전 영속성 컨텍스트에 저장된 데이터가 있는지 확인한다.
                  ○ 동일 데이터가 존재하면 update, 없으면 insert를 수행한다,
                  ○ JPA가 실제로 수행하는 쿼리는 모든 컬럼을 변경한다.
                  ○ 컬럼이 굉장히 많은(30개 이상) 테이블이 아니면 성능에 크게 영향을 미치지 않는다.
                  ○ 엔티티 클래스에 @DynamicUpdate 어노테이션을 붙여주면 SET절에 변경된 데이터만 삽입된다.
                (5) 지연 로딩
            ● 준영속 : 영속성 컨텍스트에 저장되어 있었으나 분리된 상태
              ○ 경우 1) detach 시킨 영속 상태의 엔티티
              ○ 경우 2) 영속성 컨텍스트 자체가 초기화/종료될때 해당 컨텍스트 내부에 존재했던 모든 데이터
              ○ 관리되지는 않는 상태이지만 JPA의 지원을 받지 못할 뿐, 정상적인 데이터를 갖는 인스턴스
            ● 삭제 : 영속성 컨텍스트에서 완전히 삭제된 상태
          </pre>
        </li>
        <li>영속성 컨텍스트 - 플러시 (flush)
          <pre>
            ● 영속성 컨텍스트의 변경 내용을 DB에 반영하는 절차
            ● 작동 순서
              1. 데이터의 변경을 감지한다.
              2. 생성된 쿼리를 쓰기 지연 저장소에 등록한다.
              3. commit되면 저장되어 있던 쿼리를 모두 수행한다.
            ● 플러시 모드
              ○ @FlushModeType.AUTO (default): commit이나 쿼리 실행할 때 플러시
              ○ @FlushModeType.COMMIT : commit할 때만 플러시
            ● 직접 플러시를 하고 싶을 때는 flush 메소드를 실행하면 된다.
            <pre class="prettyprint lang-java">
              em.flush();
            </pre>
          </pre>
        </li>
        <li>영속성 컨텍스트 - 종료
          <pre>
            ● close 메소드를 실행하면 된다.
            <pre class="prettyprint lang-java">
              em.close();
            </pre>
          </pre>
        </li>
        <li>영속성 컨텍스트 - 병합
          <pre>
            ● 준영속 상태의 데이터는 병합 기능을 사용하여 다시 영속 상태로 돌릴 수 있다.
            <pre class="prettyprint lang-java">
              SomeEntity entity = em.find(key);
              em.detach(entity);
              em.merge(entity);
            </pre>
          </pre>
        </li>
        <li>영속성 전이
          <pre>
            ● 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만드는 것

            ● 옵션
              ○ ALL : PERSIST + REMOVE
              ○ PERSIST : 특정 엔티티를 영속 상태로 변경 시 연관 엔티티도 영속 상태로 변경
              ○ REMOVE : 특정 엔티티 삭제 시 관련 엔티티도 연관 엔티티도 함께 삭제
              ○ MERGE : 특정 엔티티 병합 시 연관 엔티티도 함께 병합
              ○ REFRESH : 특정 엔티티 새로고침 시 연관 엔티티도 새로고침
              ○ DETACH : 특정 엔티티에서 detach() 수행 시 연관 엔티티도 detach() 수행

            ● 예시
            <pre class="prettyprint lang-java">
              @ManyToOne(cascade = { CascadeType.ALL })
              @ToString.Exclude
              private Publisher publisher;
            </pre>
          </pre>
        </li>
        <li>고아 객체
          <pre>
            ● 부모 엔티티와 연관 관계가 끊어진 자식 엔티티
            ● orphanRemoval = true 옵션을 활성화하면 고아 객체가 된 엔티티를 자동으로 삭제해준다.
            ● 예시
            <pre class="prettyprint lang-java">
              @OneToMany(orphanRemoval = true)
              @JoinColumn(name = "publisher_id")
              @ToString.Exclude
              private List&lt;Book&gt; books = new ArrayList&lt;&gt;();
            </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="jpaCache">
      <header class="note_title">JPA - Cache</header>
      <ul>
        <li>1차 캐시
          <pre>
            ● 영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소
              ○ 트랜잭션이 시작하고 종료할 때 까지만 1차 캐시가 유효하다. (일반적인 경우)
              ○ 클라이언트의 요청이 들어올 때부터 끝날때 까지만 1차 캐시가 유효하다. (OSIV를 사용하는 경우)
            ● 데이터베이스 접근 횟수를 획기적인 정도로 줄여주는 건 아니다.
            ● Entity Manager로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장된다.
            ● 1차 캐시는 임의로 on/off할 수 있는 옵션이 아니다.
            ● 영속성 컨텍스트 자체가 사실상 1차 캐시와 같다고 볼 수 있다.
            ● 동작 순서 :
              find 호출 → 영속성 컨텍스트에 캐시된 데이터 조회 → if(Data X) DB 접근 및 데이터 로드 후 1차 캐시 데이터에 저장 → 결과 반환
            ● 단, 최초 조회시에는 바로 DB에서 조회한다. 같은 엔티티를 조회하는 경우에 1차 캐시에에서 조회한다.
          </pre>
        </li>
        <li>2차 캐시 (= 공유 캐시)
          <pre>
            ● 하이버네이트를 포함한 대부분의 JPA 구현체들이 지원하는 애플리케이션 범위의 캐시
            ● 애플리케이션을 종료할 때까지 유지되는 캐시
            ● 분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지 될 수도 있다.
            ● 동작 순서 :
              find 호출 → 2차 캐시에서 우선조회 → if(Data X) DB 접근 및 데이터 로드 후 2차 캐시 데이터에 저장
              → 해당 엔티티를 복사  → 복사한 엔티티를 반환
            ● 2차 캐시를 적절히 활용하면 데이터베이스 조회 횟수를 획기적으로 줄일 수 있다.
            ● 1차 캐시와 다르게 조회환 엔티티가 아닌 조회한 엔티티의 복사복을 반환한다.
            ● 2차 캐시는 영속성 유닛 범위의 캐시다.
            ● 2차 캐시도 데이터베이스 기본 키를 기준으로 캐시하지만
              단,영속성 컨텍스트가 다르면 동일성을 보장하지 않는다.
          </pre>
        </li>
        <li>2차 캐시 사용법 - 공통
          <pre>
            ● @Cacheable : 엔티티 캐시 적용시 사용하는 어노테이션
            ● 캐시 모드 설정 (properties 파일에서 설정)
              ○ 예시 : spring.jpa.properties.javax.persistence.sharedCache.mode=ENABLE_SELECTIVE
              ○ 속성 종류
                (1) ALL : 모든 엔티티를 캐시한다.
                (2) NONE : 캐시를 사용하지 않는다.
                (3) ENABLE_SELECTIVE : Cacheable(true)로 설정된 엔티티만 캐시를 적용한다. (주사용)
                (4) DISABLE_SELECTIVE : 모든 엔티티를 캐시하는데 Cacheable(false)만 캐시하지 않는다
                (5) UNSPECIFIED : JPA 구현체가 정의한 설정을 따른다
            ● 캐시 모드 설정 방법 (properties 파일에 속성 값 추가하기)
              #캐시 모드 설정
              spring.jpa.properties.javax.persistence.sharedCache.mode=ENABLE_SELECTIVE
            ● 캐시 조회 모드 설정
              ○ USE : 캐시에서 조회한다. (기본값)
              ○ BYPASS : 캐시를 무시하고 데이터베이스에 직접 접근한다.
            ● 캐시 저장 방식 설정
              ○ USE : 조회한 데이터를 캐시에 저장. (기본값)
                (1) 조회한 데이터가 이미 캐시에 있으면 캐시 데이터를 최신 상태로 갱신하지는 않는다.
                (2) 트랜잭션을 커밋하면 등록/수정한 엔티티도 캐시에 저장한다.
              ○ BYPASS : 캐시에 저장하지 않는다.
              ○ REFRESH : USE 전략에 추가로 데이터베이스에서 조회한 엔티티를 최신 상태로 다시 캐시한다.
            ● 캐시 조회/저장 방식 설정에 대한 예시
            <pre class="prettyprint lang-java">
              //Entity Manager 범위 적용
              em.setProperty("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);

              //find()
              Map&lt;String, Object&gt; param = new HashMap&lt;String, Object&gt;();
              param.put("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);
              param.put("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS);
              em.find(SomeEntity.class, id, param);
            </pre>
          </pre>
        </li>
        <li>2차 캐시 사용법 - JPA
          <pre>
            ● javax.persistence.Cache 인터페이스 제공
            <pre class="prettyprint lang-java">
              public interface Cache {
                  // 해당 엔티티가 캐시에 있는지 여부 확인
                  public boolean contains(Class cls, Object primaryKey);
                  // 해당 엔티티중 특정 식별자를 가진 엔티티를 캐시에서 제거
                  public void evict(Class cls, Object primaryKey);
                  // 해당 엔티티 전체를 캐시에서 제거
                  public void evict(Class cls);
                  // 모든 캐시 데이터 제거
                  public void evictAll();
                  // JPA Cache 구현체 조회
                  public <T> T unwrap(Class<T> cls);
              }
            </pre>

            <pre class="prettyprint lang-java">
              public interface Cache {
                //캐시 관리 객체 조회
                Cache cache = emf.getCache();
                boolean contains = cache.contains(SomeEntity.class, someEntity.getId());
              }
            </pre>
          </pre>
        </li>
        <li>2차 캐시 사용법 - 하이버네이트
          <pre>
            ● @Cache : 하이버네이트에서 제공하는 캐시 설정 어노테이션
              ○ 캐시와 관련된 더 세밀한 설정을 할 때 사용
              ○ 컬렉션 캐시를 적용할 때에도 사용
            ● @Cache 어노테이션의 속성
              ○ usage : CacheConcurrencyStrategy 를 사용해서 캐시 동시성 전략을 설정
                (1) NONE : 캐시 설정 X
                (2) READ_ONLY :
                  ○ 읽기 전용 설정
                  ○ 등록/삭제 가능
                  ○ 수정 불가능
                  ○ 읽기 전용인 불변 객체는 수정 X → 2차 캐시 조회 시 객체를 복사하지 않고 원본 객체를 반환
                (3) NONSTRICT_READ_WRITE :
                  ○ 엄격하지 않은 읽고 쓰기 전략
                  ○ 동시에 같은 엔티티 수정 시 데이터 일관성이 깨질 수 있다.
                  ○ EHCACHE는 데이터 수정 시 캐시 데이터를 무효화
                (4) READ_WRITE :
                  ○ 읽기/쓰기 가능
                  ○ READ COMMITTED 정도의 격리 수준을 보장
                  ○ EHCACHE는 데이터 수정 시 캐시 데이터도 같이 수정
                (5) TRANSACTIONAL :
                  ○ 컨테이너 관리 환경에서 사용 가능
                  ○ 설정에 따라 REPEATABLE READ 정도의 격리 수준을 보장
              ○ region : 캐시 지역 설정
              ○ include : 연관 객체를 캐시에 포함할지 선택, 종류 : all/non-lazy, 기본값 : all
            ● 환경설정
              1. 의존성 추가하기
              <pre class="prettyprint lang-xml">
                &lt;dependency>
                    &lt;groupId>org.hibernate&lt;/groupId>
                    &lt;artifactId>hibernate-ehcache&lt;/artifactId>
                &lt;/dependency>
              </pre>
              2. properties 파일에 속성 값 추가하기
                #2차 캐시 활성화
                spring.jpa.properties.hibernate.cache.use_second_level_cache=true
                #2차 캐시를 처리할 클래스를 지정
                spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
                #캐시 적용 여부를 확인 (하이버네이트 자체 제공 기능)
                spring.jpa.properties.hibernate.generate_statistics=true
            ● 하이버네이트가 지원하는 캐시
              ○ 엔티티 캐시
                (1) 엔티티 단위로 캐시한다.
                (2) 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용한다.
              ○ 컬렉션 캐시
                (1) 엔티티와 연관된 컬렉션을 캐시한다.
                (2) 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다.
              ○ 쿼리 캐시
                (1) 쿼리와 파라미터 정보를 키로 사용해서 캐시한다.
                (2) 결과가 엔티티면 식별자 값만 캐시한다.
            <pre class="prettyprint lang-java">
              //Entity Manager 범위 적용
              em.setProperty("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);

              //find()
              Map&lt;String, Object&gt; param = new HashMap&lt;String, Object&gt;();
              param.put("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);
              param.put("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS);
              em.find(SomeEntity.class, id, param);
            </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="transactionManager">
      <header class="note_title">Transaction Manager</header>
      <ul>
        <li>트랜잭션 매니저란?
          <pre>
            ● 스프링에서 제공하는 트랜잭션 처리를 위한 추상화 클래스
            ● 트랜잭션 관리는 서비스 클래스에서 진행하는 것을 권장한다.
            ● 예외 발생가 발생하게 되면 예외가 발생하기 전까지 진행했던 DB 처리 작업들을 모두 롤백시킨다. (DAO 메소드)
            ● 트랜잭션 관리가 필요한 쿼리의 종류는 INSERT, UPDATE, DELETE 총 3가지이다.
            ● Spring에서는 일관적인 트랜잭션 관리를 위해서 spring-tx 클래스를 제공한다.
          </pre>
        </li>
        <li>기본 사용방법
          <pre>
            ● @Transactional 어노테이션을 사용한다. (org.springframework.transaction.annotation.Transactional)
            ● 메소드, 클래스, 인터페이스 위에 추가하여 사용하다. (선언적 트랜잭션)
            ● @Transactional 어노테이션이 적용된 범위에서는
              트랜잭션 기능이 포함된 프록시 객체가 생성되어
              자동으로 commit/rollback을 진행한다.
            ● 사용 예시)
              <pre class="prettyprint lang-java">
                @Service
                @RequiredArgsConstructor
                public class MemberService {
                  private final MemberRepository memberRepository;

                    @Transactional(propagation =  Propagation.NESTED)
                    public void putMember() {
                        Member member = new Member();
                        member.setName("HongGilDong");
                        member.setPhoneNumber("010-1234-1234");
                        member.setGender("M");

                        memberRepository.save(member);
                    }
                }
              </pre>
          </pre>
        </li>
        <li>@Transactional의 옵션
          <pre>
            ● isolation : 트랜잭션에서 일관성없는 데이터 허용 수준을 설정한다.
              ○ DEFAULT (기본값) : DB의 lsolation Level을 따른다.
              ○ READ_UNCOMMITED (level 0) : 커밋되지 않는 데이터에 대한 읽기를 허용한다.
              ○ READ_COMMITED (level 1) : 커밋된 데이터에 대해 읽기를 허용한다.
              ○ REPEATEABLE_READ (level 2) : 동일 필드에 대해 다중 접근 시 모두 동일한 결과를 보장한다.
              ○ SERIALIZABLE (level 3) : 가장 높은 격리, 성능 저하의 우려가 있음
              ○ 사용법 예시
                <pre class="prettyprint lang-java">
                  @Transactional(isolation =  Isolation.READ_COMMITED)
                </pre>

            ● propagation : 트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 지정하는 옵션이다.
              ○ REQUIRED (기본값)
                (A) 이미 진행중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따른다.
                (B) 진행중이 아니라면 새로운 트랜잭션을 생성한다.
              ○ REQUIRES_NEW
                (A) 항상 새로운 트랜잭션을 생성한다.
                (B) 이미 진행중인 트랜잭션이 있다면 잠깐 보류하고 해당 트랜잭션 작업을 먼저 진행한다.
              ○ SUPPORT
                (A) 이미 진행 중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따른다.
                (B) 진행 중인 트랜잭션이 없다면 트랜잭션을 설정하지 않는다.
              ○ NOT_SUPPORT : 이미 진행중인 트랜잭션이 있다면 보류하고, 트랜잭션 없이 작업을 수행한다.
              ○ MANDATORY
                (A) 이미 진행 중인 트랜잭션이 있어야만 작업을 수행한다.
                (B) 진행 중인 트랜잭션이 없다면 Exception을 발생시킨다.
              ○ NEVER
                (A) 트랜잭션이 진행중이지 않을 때 작업을 수행한다.
                (B) 진행중인 트랜잭션이 있다면 Exception을 발생시킨다.
              ○ NESTED
                (A) 진행중인 트랜잭션이 있으면 중첩된 트랜잭션이 실행된다.
                (B) 진행중인 트랜잭션이 없으면 REQUIRED와 동일하게 실행된다.
              ○ 사용법 예시
                <pre class="prettyprint lang-java">
                  @Transactional(propagation =  Propagation.NESTED)
                </pre>

              ● noRollbackFor : 특정 예외 발생 시 rollback하지 않는다.
                ○ 사용법 예시
                <pre class="prettyprint lang-java">
                  @Transactional(noRollbackFor=Exception.class)
                </pre>

              ● rollbackFor
                ○ 특정 예외 발생 시 rollback한다.
                ○ @Transactional 은 기본적으로 Unchecked Exception, Error 만을 rollback한다.
                  => 모든 예외에 대해서 롤백시키기 위해서는 모든 예외의 기본 클래스인 Exception 클래스를 옵션으로 설정한다.
                ○ 사용법 예시
                <pre class="prettyprint lang-java">
                  @Transactional(rollbackFor=Exception.class)
                </pre>

              ● timeout
                ○ 지정한 시간 내에 메소드 수행이 완료되지 않으면 rollback 한다.
                ○ 옵션 값이 -1일 경우에는 timeout을 사용하지 않는다. (= no timeout)
                ○ 사용법 예시
                <pre class="prettyprint lang-java">
                  @Transactional(timeout=10)
                </pre>

              ● readOnly
                ○ 트랜잭션을 읽기 전용으로 설정한다.
                ○ 기본값 : flase
                ○ readonly = true 설정 시 insert, update, delete 실행 시 예외 발생
                ○ 사용법 예시
                <pre class="prettyprint lang-java">
                  @Transactional(readonly = true)
                </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="jpaQuery">
      <header class="note_title">JPA 쿼리</header>
      <ul>
        <li>JPQL
          <pre>
            ● 테이블이 아닌 엔티티 객체를 대상으로 검색하는 객체지향 쿼리
            ● from절 뒤에 테이블명이 아닌 객체명이 붙는다.
            ● 반드시 객체명과 동일하게 명시해야 한다. (대소문자 오타 실수 주의)
            ● 전체 검색을 할 때 *이 아닌 객체명이나 별칭을 명시한다.
            ● 예시
            <pre class="prettyprint lang-java">
              //파라미터 사용 방법
              //쿼리 => name 사용시 :name으로 명시
              //파라미터 => name 사용 시 @Param("name") String name으로 명시
              @Query(value="SELECT m FROM Member AS m WHERE m.name = :name")
              public Member findByName(@Param("name") String name);
            </pre>
          </pre>
        </li>
        <li>Native SQL
          <pre>
            ● @Query 어노테이션에서 원래의 쿼리를 쓰는 방식
            ● nativeQuery = true 옵션 활성화가 필요하다.
            ● 예시
            <pre class="prettyprint lang-java">
              //파라미터 사용 방법
              //쿼리 => name 사용시 :name으로 명시
              //파라미터 => name 사용 시 @Param("name") String name으로 명시
              @Query(value = "SELECT * FROM member AS m WHERE m.name = :name", nativeQuery = true)
              public Member findByName(@Param("name") String name);
            </pre>
          </pre>
        </li>
        <li>Converter
          <pre>
            ● 엔티티의 데이터를 변환하는 기능
            ● useYN같이 DB에서는 String이지만 객체에서는 boolean으로 저장하고 싶을 때 사용한다.
            ● 항상 적용되기 원하면 autoApply=true 옵션을 활성화하면 된다.
            ● 예시
            <pre class="prettyprint lang-java">
              @Entity
              class Member{
                  @Id
                  @GeneratedValue
                  private Integer id;

                  @Convert(converter=BooleanToYNConverter.class)
                  private boolean useYn;
              }

              @Converter(autoApply=true)
              class ConverterBooleanToYN implements AttributeConverter&lt;Boolean, String&gt;{
                  @Override
                  public String convertToDatabaseColumn(Boolean value){
                      return (value != null && value) ? "Y" : "N";
                  }

                  @Override
                  public Boolean convertToEntityAttribute(String dbData){
                      return "Y".eqauls(dbData);
                  }
              }
            </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="embeddedType">
      <header class="note_title">임베디드 타입</header>
      <ul>
        <li>정의
          <pre>
            ● JPA에서 정의한 사용자 정의 값 타입
            ● 예시 1) 근무 시작 기간 & 근무 종료 기간 =(임베디드 타입으로 정의)=> 근무 기간
            ● 예시 2) 우편번호 & 지역 정보 & 상세 주소 =(임베디드 타입으로 정의)=> 거주정보
            ※ 하이버네이트에서의 컴포넌트와 같은 것을 의미한다.
          </pre>
        </li>
        <li>사용법
          <pre>
            ● @Embeddable: 값 타입을 정의하는 곳에 표시
            ● @Embedded: 값 타입을 사용하는 곳에 표시
            ※ 임베디드 타입은 기본 생성자가 필수다.
          </pre>
        </li>
        <li>장점
          <pre>
            ● 재사용성
            ●높은 응집도
            ● 해당 값 타입만 사용하는 의미있는 메서드를 만들 수 있다.
          </pre>
        </li>
        <li>예외사항 (칼럼명이 겹치는 경우)
          <pre>
            ● 재사용성
            ●높은 응집도
            ● 해당 값 타입만 사용하는 의미있는 메서드를 만들 수 있다.
            ● 예시
            <pre class="prettyprint lang-java">
              @Entity
              public class Member {
                
                @Id
                @GeneratedValue
                private Long id;
                private String name;
                
                @Embedded
                Address homeAddress;
                
                @Embedded
                @AttributeOverrides({
                  @AttributeOverride(name="area", column=@Column(name="COMPANY_AREA")),
                  @AttributeOverride(name="city", column=@Column(name="COMPANY_CITY")),
                  @AttributeOverride(name="street", column=@Column(name="COMPANY_STREET")),
                  @AttributeOverride(name="building", column=@Column(name="COMPANY_BUILDING")),
                  @AttributeOverride(name="homeNumber", column=@Column(name="COMPANY_HOMENUMBER"))
                })
                Address companyAddress;
              }

              @Embeddable
              public class Address {
                String area;
                String city;
                String street;
                String building;
                String homeNumber;
              }
            </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="h2db">
      <header class="note_title">H2 Database</header>
      <ul>
        <li>H2 Database
          <pre>
            ● Java 기반의 경량화된 관계형 DB
            ● 파일로 저장해서 실제 DB처럼 데이터 유지 가능
            ● 메모리 DB로 사용해서 실제 인스턴스가 동작 시점에만 유지하는 것도 가능
            ● 테스트 DB로 주로 사용
            ● 유지보수 시 JUnit 테스트용으로 주로 사용
            ● 서버를 재기동시 초기화
          </pre>
        </li>
        <li>설치방법 (Spring Boot 기준)
          <pre>
            1. pom.xml에 dependency 추가
              <pre class="prettyprint lang-xml">
                &lt;dependency>
                    &lt;groupId>com.h2database&lt;/groupId>
                    &lt;artifactId>h2&lt;/artifactId>
                    &lt;scope>runtime&lt;/scope>
                &lt;/dependency>
              </pre>

            2. application.properties 파일에 정보 추가 (※ 기본 계정 : sa)
                spring.datasource.url=jdbc:h2:~/DB명; #DB 고정
                spring.datasource.driverClassName=org.h2.Driver
                spring.datasource.username=sa
                spring.datasource.password=
                spring.h2.console.enabled=true
                spring.h2.console.path=/h2-console /*기본값*/
            
            3. 프로젝트 실행
            4. http://localhost:포트주소/h2-console로 이동
          </pre>
        </li>
        <li>자신의 memory DB의 주소를 알기 위한 코드
          <pre>
            <pre class="prettyprint lang-java">
              package com.example.demo;
  
              import java.sql.SQLException;
  
              import org.springframework.beans.factory.annotation.Autowired;
              import org.springframework.boot.ApplicationArguments;
              import org.springframework.boot.ApplicationRunner;
              import org.springframework.stereotype.Component;
  
              import javax.sql.DataSource;
              import java.sql.Connection;
  
              @Component
              public class DatabaseConfig implements ApplicationRunner {
  
                  @Autowired
                  DataSource dataSource;
  
                  @Override
                  public void run(ApplicationArguments args) throws SQLException {
                      try(Connection connection = dataSource.getConnection()){
                          System.out.println(connection.getMetaData().getURL());
                          System.out.println(connection.getMetaData().getUserName());
                      } catch (Exception e){
                          System.out.println(e);
                      }
                  }
              }
            </pre>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="mysql">
      <header class="note_title">MySql Database</header>
      <ul>
        <li>설치방법 (Spring Boot 기준)
          <pre>
            1. pom.xml에 dependency 추가
              <pre class="prettyprint lang-xml">
                &lt;dependency>
                    &lt;groupId>mysql&lt;/groupId>
                    &lt;artifactId>mysql-connector-java&lt;/artifactId>
                    &lt;version>8.0.22&lt;/version>
                &lt;/dependency>
              </pre>

            2. application.properties 파일에 정보 추가 (※ 기본 계정 : root)
                #ddl-auto 옵션이 generate-ddl 옵션보다 상위로 적용되는 옵션이다.
                spring.jpa.generate-ddl=true
                spring.jpa.hibernate.ddl-auto=create-drop
                #ddl-auto > create 옵션 : 자동 추가
                #ddl-auto > create-drop 옵션 : 자동 추가 및 삭제

                spring.datasource.url=jdbc:mysql//localhost:3306/book_manager
                spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
                spring.datasource.username=root
                spring.datasource.password=
                spring.datasource.initialization-mode=always
            
            3. 프로젝트 실행
            4. http://localhost:포트주소/h2-console로 이동
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="log">
      <header class="note_title">로그 출력하기</header>
      <ul>
        <li>JPA 쿼리 로그 출력 설정법
          <pre>
            #JPA 로그 출력 설정
            spring.jpa.show-sql=true

            #JPA 로그의 모양을 단정하게 하기
            spring.jpa.properties.hibernate.format_sql=true
            
            #JPA 로그의 ? 부분을 실제 값으로 치환
            logging.level.org.hibernate.type.descriptor.sql=TRACE
          </pre>
        </li>
      </ul>
    </section>

    <div id="remote">
      <section id="remote_setcion">
        <select id="remote_menu" onchange="move_section()">
          <option value="intro">JPA</option>
          <option value="installAndConnnecting">설치 및 연결</option>
          <option value="JpaRepository">JPA - Repository</option>
          <option value="jpaEntity">JPA - Entity</option>
          <option value="relation">연관관계</option>
          <option value="persistence">영속성</option>
          <option value="jpaCache">JPA - Cache</option>
          <option value="transactionManager">Transaction Manager</option>
          <option value="jpaQuery">JPA 쿼리</option>
          <option value="embeddedType">임베디드 타입</option>
          <option value="h2db">H2 Database</option>
          <option value="mysql">MySql Database</option>
          <option value="log">로그 출력하기</option>
        </select>
      </section>
    </div>
  </body>

  <!--code pretty print -->
  <script src ="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

  <script>
      prettyPrint();
  </script>
</html>
