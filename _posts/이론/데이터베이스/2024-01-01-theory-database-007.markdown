---
layout: post
title:  "관계 데이터 연산"
date:   2024-01-01 23:00:00 +0900
categories: 이론&nbsp;-&nbsp;데이터베이스
---

## 관계 데이터 연산 (relationship data operation)

- 관계 데이터 모델의 연산
- 원하는 데이터를 얻기 위해 릴레이션엥 필요한 처리 요구를 수행하는 것
- 종류
    - 관계 대수 (relational algebra)
        - 원하는 결과를 얻기 위해 데이터의 처리 과정을 순서대로 기술하는 절차 언어
    - 관계 해석 (relational calculus)
        - 원하는 결과를 얻기 위해 처리를 원하는 데이터가 무엇인지만 기술하는 비절차 언어
- 사용자의 입장에서는 처리 과정을 자세히 기술하는 것보다  
처리를 원하는 데이터가 무엇인지만 기술하는 비절차 언어가 더 편리하게 느껴질 수 있다.
- 데이터를 처리하는 기능과 처리를 요구하는 표현력에서는 관계 대수와 관계 해석은 능력이 동등하다.
- 관계 대수와 관계 해석으로 기술된 데이터 처리 요구는 반대되는 연산으로 기술할 수 있다.
- 새로운 데이터 언어가 제안되면 해당 데이터 언어의 유용성을 검증해야 하는데,  
    그런 검증의 기준 역할을 하는 것이 관계 대수와 관계 해석이다.
    - <b>관계적으로 완전하다. (relationally complete)</b>
        - 관계 대수나 관계 해석으로 기술할 수 있는  
        모든 질의를 새로 제안된 데이터 언어로 기술할 수 있는 상태
- 질의 (query)
    - 데이터에 대한 처리 요구

## 관계 대수

- 원하는 결과를 얻기 위해 릴레이션을 처리하는 과정을 순서대로 기술하는 언어
- 연산자들의 집합으로도 정의할 수 있다.
- 관계 대수는 릴레이션을 연산한다.
- 폐쇠 특성 (closure property)
    - 릴레이션에 연산자를 적용해 얻은 결과도 릴레이션이라는 관계 대수의 특성
- 종류
    - 일반 집합 연산자 (set operation)
        - 합집합 (∪)
        - 교집합 (∩)
        - 차집합 (-)
        - 카티션 프로덕트 (x)
    - 순수 관계 연산자 (relational operation)
        - 셀렉트 (σ)
        - 프로젝트 (π)
        - 조인 (⋈)
        - 디비전 (÷)

### 일반 집합 연산자

- 수학의 집합 관련 연산자를 차용한 연산자
- 릴레이션이 투플의 집합이라는 개념을 이용한다.
- 연산을 위해서는 피연산자인 릴레이션이 두 개 필요하다.
- 합집합/교집합/차집합 연산자는 피연산자인 두 개의 릴레이션끼리 합병 가능해야 한다.
- 릴레이션의 합병 가능 조건
    - 두 릴레이션의 차수(속성의 개수)가 같다.
    - 두 릴레이션에서 대응되는 속성의 도메인이 같다.
        - 도메인이 같으면 속성명은 달라도 된다.

| 연산자 | 기호 | 표현 | 의미 |
|-------|--------|---------|---------|
| 합집합 | ∪ | R ∪ S | 릴레이션 R과 S의 합집합을 반환 |
| 교집합 | ∩ | R ∩ S | 릴레이션 R과 S의 교집합을 반환 |
| 차집합 | - | R - S | 릴레이션 R과 S의 차집합을 반환 |
| 카티션 프로덕트 | x | R x S | 릴레이션  R의 각 투플과 릴레이션 S의 각 투플을<br/>모두 연결하여 만들어진 새로운 투플을 반환 |

#### 합집합 (union)

- 합병이 가능한 두 릴레이션 R과 S의 합집합은 R ∪ S로 표현헌더,
- R ∪ S는 릴레이션 R에 속하거나 또는 릴레이션 S에 속하는 모든 투플로 결과 릴레이션을 구성한다.
- 중복된 투플은 중복되지 않고 한 번만 나타난다.
    - 합집합의 결과도 릴레이션이기 때문에 중복 투플이 존재할 수 없다는  
    릴레이션의 기본 특징을 유지해야 하기 때문이다.
- 교환적 특징
    - R ∪ S와 S ∪ R의 결과는 동일하다.
- 결합적 특징
    - (R ∪ S) ∪ T와 R ∪ (S ∪ T)의 결과는 동일하다.

R

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 200 | 김선우 |
| 300 | 고명석 |

S

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 101 | 채광주 |
| 102 | 김수진 |

R ∪ S

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 200 | 김선우 |
| 300 | 고명석 |
| 101 | 채광주 |
| 102 | 김수진 |

#### 교집합 (intersection)

- 합병이 가능한 두 릴레이션 R과 S의 교집합은 R ∩ Sfh vygusgksek.
- R ∩ S는 릴레이션 R과 S에 속하는 모든 투플ㄹ로 결과 릴레이션을 구성한다.
- 교환적 특징
    - R ∩ S와 S ∩ R의 결과는 동일하다.
- 결합적 특징
    - (R ∩ S) ∩ T와 R ∩ (S ∩ T)의 결과는 동일하다.
R

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 200 | 김선우 |
| 300 | 고명석 |

S

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 101 | 채광주 |
| 102 | 김수진 |

R ∩ S

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |

#### 차집합 (difference)

- 합병이 가능한 두 릴레이션 R과 S의 차집합은 R - S로 표현한다.
- R - S는 릴레이션 R에는 존재하지만 릴레이션 S에는 존재하지 않는 투플들로 결과 릴레이션을 구성한다.
- 차집합은 피연산자의 순서에 따라서 결과 릴레이션이 달라진다.

R

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 200 | 김선우 |
| 300 | 고명석 |

S

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 101 | 채광주 |
| 102 | 김수진 |

R - S

| 번호 | 이름 |
|-------|--------|
| 200 | 김선우 |
| 300 | 고명석 |

S - R

| 번호 | 이름 |
|-------|--------|
| 101 | 채광주 |
| 102 | 김수진 |

#### 카티션 프로덕트 (cartesian product)

- 두 릴레이션 R과 S의 카티션 프로덕트는 R x S로 표현한다.
- R x S는 릴레이션 R에 속한 각 투플과 릴레이션 S에 속한 각 투플을 모두 연결하여 만들어진  
새로운 투플로 결과 릴레이션을 구성한다.
- 교환적 특징
    - R x S와 S x R의 결과는 동일하다.
- 결합적 특징
    - (R x S) x T와 R x (S x T)의 결과는 동일하다.

R

| 번호 | 이름 |
|-------|--------|
| 100 | 정소화 |
| 200 | 김선우 |
| 300 | 고명석 |

S

| 번호 | 나이 |
|-------|--------|
| 100 | 40 |
| 101 | 30 |
| 102 | 25 |

R x S

| R.번호 | R.이름 | S.번호 | S.나이 |
|-------|--------|--------|--------|
| 100 | 정소화 | 100 | 40 |
| 100 | 정소화 | 101 | 30 |
| 100 | 정소화 | 102 | 25 |
| 200 | 김선우 | 100 | 40 |
| 200 | 김선우 | 101 | 30 |
| 200 | 김선우 | 102 | 25 |
| 300 | 고명석 | 100 | 40 |
| 300 | 고명석 | 101 | 30 |
| 300 | 고명석 | 102 | 25 |

### 순수 관계 연산자

- 릴레이션의 구조와 특성을 이용하는 연산자
- 관계 데이터 모델에서 새로 제시된 연산자
- 릴레이션에 저장되어 있는 데이터를 다양하게 처리하는데 사용된다.

| 연산자 | 기호 | 표현 | 의미 |
|-------|--------|---------|---------|
| 셀렉트 | σ | σ<sub>조건식</sub>(R) | 릴레이션 R에서 조건을 만족하는 투플들을 반환 |
| 프로젝트 | π | π<sub>속성리스트</sub>(R) | 릴레이션 R에서 주어진 속성들의 값으로만 구성된 투플들을 반환 |
| 조인 | ⋈ | R ⋈ S | 공통 속성을 이용해 릴레이션 R과 S의 투플들을 연결하여 만들어진<br/>새로운 투플들을 반환 |
| 디비전 | ÷ | R ÷ S | 릴레이션 S의 모든 투플과 관련이 있는 릴레이션 R의 투플들을 반환 |

#### 셀렉트 (select)

- 릴레이션에서 주어진 조건을 만족하는 투플만 선택하여 결과 릴레이션을 구성하는 연산
- 결과 릴레이션은 주어진 릴레이션을 수평으로 절단한 것과 같아  
해당 릴레이션의 수평적 부분 집합을 생성하는 것과 같다.
- 기본 형식
    - <b>σ<sub>조건식</sub>(릴레이션)</b> 또는 <b>릴레이션 where 조건식</b>
- 하나의 릴레이션을 대상으로 수행한다.
- 조건식은 비교 연산자를 이용해 구성한다.
    - 논리 연산자도 함꼐 사용해 조건식을 좀 더 복잡학 구성할 수도 있다.
- 조건식을 비교식 또는 프레디킷(predicate)라고 부른다.
- 조선식을 속성과 상수의 비교나 다른 속성들 간의 비교로 표현할 수 있다.
- 조건식을 속성과 상수의 비교로 궝할 때는 상수의 데이터 타입이 속성의 도메인과 일치해야 한다.
- 조건식을 다른 속성들 간의 비교로 구성할 때는 속성들의 도메인이 같아야 비교가 가능하다.
- 교환적 특성
    - <b>σ<sub>조건식1∧조건식2</sub>(릴레이션)</b>  
    = <b>σ<sub>조건식1</sub>(σ<sub>조건식2</sub>(릴레이션))</b>  
    = <b>σ<sub>조건식2</sub>(σ<sub>조건식1</sub>(릴레이션))</b>

고객 릴레이션

| 고객아이디 | 고객이름 | 나이 | 등급 | 직업 | 적립금 |
|-------|--------|---------|---------|---------|---------|
| apple | 김현준 | 20 | gold | 학생 | 1000 |
| banana | 정소화 | 25 | vip | 간호사 | 2500 |
| carrot | 원유선 | 28 | gold | 교사 | 4500 |
| orange | 정지영 | 22 | silver |학생 | 0 |

등급이 gold이고, 적립금이 2000 이상인 경우  
<b>σ<sub>등급='gold'∧적립급≥2000</sub>(고객)</b> 또는 <b>고객 where 등급 = 'gold' and 적립급 ≥ 2000</b>

| 고객아이디 | 고객이름 | 나이 | 등급 | 직업 | 적립금 |
|-------|--------|---------|---------|---------|---------|
| carrot | 원유선 | 28 | gold | 교사 | 4500 |

#### 프로젝트 (project)

- 릴레이션에서 선택한 속성의 값으로 결과 릴레이션을 구성하는 연산
- 결과 릴레이션이 주어진 릴레이션의 일부 열로만 구성되어  
해당 릴레이션의 수직적 부분 집합을 생성하는 것과 같다.
- 릴레이션의 기본 특성을 유지하기 위해 중복되는 값은 노출되지 않는다.
- 기본 형식
    - <b>π<sub>속성리스트</sub>(릴레이션)</b> 또는 <b>릴레이션[속성리스트]</b>

고객 릴레이션

| 고객아이디 | 고객이름 | 나이 | 등급 | 직업 | 적립금 |
|-------|--------|---------|---------|---------|---------|
| apple | 김현준 | 20 | gold | 학생 | 1000 |
| banana | 정소화 | 25 | vip | 간호사 | 2500 |
| carrot | 원유선 | 28 | gold | 교사 | 4500 |
| orange | 정지영 | 22 | silver | 학생 | 0 |

고객이름, 등급, 적립금 검색  
<b>π<sub>고객이름,등급,적립금</sub>(고객)</b> 또는 <b>고객[고객이름,등급,적립금]</b>

| 고객이름 | 등급 |  적립금 |
|-------|--------|---------|
| 김현준 | gold| 1000 |
| 정소화 | vip | 2500 |
| 원유선 | gold | 4500 |
| 정지영 | silver | 학생 |


#### 조인 (join)

- 릴레이션 하나로 원하는 데이터를 얻을 수 없어  
관계가 있는 여러 릴레이션을 함께 사용하는 연산
- 조인 속성을 이용해 두 릴레이션을 조합하여 하나의 결과 릴레이션을 구성한다.
- 조인 연산한 결과 릴레이션은 피연산자 릴레이션에서 조인 속성의 값이 같은 투플만 연결하여  
만들어진 새로운 투플을 포함한다.
- 조인 연산의 결과 릴레이션에서 조인 속성은 중복되지 않고 한번만 나타난다.
- 조인 속성 (join attribute)
    - 두 릴레이션이 공통으로 가지고 있는 속성
    - 두 릴레이션이 관계가 있음을 나타내는 속성
- 기본 형식
    - <b>릴레이션1 ⋈ 릴레이션2</b>

고객 릴레이션

| 고객아이디 | 고객이름 | 나이 | 등급 |
|-------|--------|---------|---------|
| apple | 김현준 | 20 | gold |
| banana | 정소화 | 25 | vip |
| carrot | 원유선 | 28 | gold |
| orange | 정지영 | 22 | silver |

주문 릴레이션

| 주문번호 | 주문고객 | 주문제품 | 수량 |
|-------|--------|---------|---------|
| 1001 | apple | 진짜우동 | 10 |
| 1002 | carrot | 맛있는파이 | 5 |
| 1003 | banana | 그대로만두 | 11 |

고객 ⋈ 주문

| 고객아이디 | 고객이름 | 나이 | 등급 | 주문번호 | 주문제품 | 수량 |
|-------|--------|---------|---------|
| apple | 김현준 | 20 | gold | 1001 | 진짜우동 | 10 |
| banana | 정소화 | 25 | vip | 1003 | 그대로만두 | 11 |
| carrot | 원유선 | 28 | gold | 1002 | 맛있는파이 | 5 |

##### 자연 조인 (natural join)

- 조인 속성 값이 같은 투플끼리만 연결하여 생성된 새로운 투플로 구성하는 연산
- 일반적으로 조인이라고 하면 보통 자연 조인을 의미한다.
    - ⋈도 보통 자연 조인을 표현할 때 사용한다.
- 기본 형식
    - <b>릴레이션1 ⋈<sub>N</sub> 릴레이션2</b>

##### 세타 조인 (theta join, θ join)

- 주어진 조인 조건을 만족하는 두 릴레이션의 모든 투플을 연결한 새로운 투플로 결과 릴레이션을 구성하는 연산
- 자연 조인에 비해 좀 더 일반화된 조인
- 주어진 조인 조건을 만족하는 두 릴레이션의 모든 투플을 연결한 새로운 투플로 결과 릴레이션을 구성한다.
- 세타 조인되는 두 릴레이션의 각 속성은 같은 도메인으로 정의되어 있어야 한다.
- 자연 조인과 달리 조인 연산의 결과 릴레이션에서 조인 속성은 중복되어 나타난다.
    - 세타 조인에서 중복된 속성을 제거하면 자연 조인의 결과 릴레이션이 된다고 할 수 있다.
- 기본 형식
    - <b>릴레이션1 ⋈<sub>AθB</sub> 릴레이션2</b>
    - AθB는 조인 조건을 의미한다.
        - θ에는 비교 연산자가 들어간다.
    - A는 릴레이션1의 속성을 의미한다.
    - B는 릴레이션 2의 속성을 의미한다.
- 동일 조인 (equi-join)
    - θ 연산자가 "="인 세타 조인

##### 세미 조인 (semi join)

- 두 릴레이션 R과 S의 세미 조인은 R ⋉ S로 표현한다.
- R ⋉ S는 릴레이션 S의 조인 속성으로만 구성한 릴레이션을 릴레이션 R에 자연 조인하는 연산
- 검색에 불필요한 속성을 미리 제거하여 조인 연산의 비용을 줄일 수 있다.
- 기본 형식
    - <b>릴레이션1 ⋉ 릴레이션2</b>

##### 외부 조인 (outer join)

- 두 릴레이션 R과 S의 외부 조인은 R ⋈<sup>+</sup> S로 표현한다.
- R ⋈<sup>+</sup> S는 두 릴레이션에 자연 조인 연산을 수행할 때  
조인 속성 값이 같은 투플이 상대 릴레이션에 존재하지 않아  
조인 연산에서 제외된 모든 투플을 결과 릴레이션에 포함시킨다.
- 플이 상대 릴레이션에 존재하지 않아 조인 연산에서 제외된 모든 투플을 포함하여 결과 릴레이션을 구성하는 연산
    - 없는 부분은 NULL로 처리한다.
- 기본 형식
    - <b>릴레이션1 ⋈<sup>+</sup> 릴레이션2</b>

#### 디비전 (division)

- 두 릴레이션 R과 S의 디비전 연산은 R ÷ S로 표현한다.
- R ÷ S는 릴레이션 S의 모든 투플과 관련 있는 릴레이션 R의 투플로 결과 릴레이션을 구성한다.
    - 단, 릴레이션 R이 릴레이션 S의 모든 속성을 포함하고 있어야 한다.
    - 릴레이션 S의 모든 속성과 이름이 같은 속성을 릴레이션 R이 가지고 있어야 한다는 뜻은 아니다.
    - 릴레이션 S의 모든 속성과 도메인이 같은 속성을 릴레이션 R이 포함하고 있어야 한다는 뜻이다.

주문내역 릴레이션

| 주문고객 | 제품이름 | 제조업체 |
|-------|--------|--------|
| apple | 진짜우동 | 한빛식품 |
| carrot | 맛있는파이 | 마포과자 |
| banana | 그대로만두 | 한빛식품 |
| apple | 그대로만두 | 한빛식품 |
| carrot | 그대로만두 | 한빛식품 |

제품1 릴레이션

| 제품이름 |
|-------|
| 진짜우동 |
| 그대로만두 |

제품2 릴레이션

| 주문고객 | 제조업체 |
|-------|-------|
| 그대로만두 | 한빛식품 |

주문내역 ÷ 제품1

| apple | 제조업체 |
|-------|-------|
| 그대로만두 | 한빛식품 |

주문내역 ÷ 제품2

| 주문고객 |
|-------|
| banana |
| apple |
| carrot |

## 관계 해석

- 처리를 원하는 데이터가 무엇인지만 기술하는 비절차 언어
- 종류
    - 투플 관계 해석 (tuple relactional calculus)
    - 도메인 관계 해석 (domain relactional calculus)