<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Boot 공부</title>
    <!-- code pretty print -->
    <link rel="stylesheet" href="./css/codePrettyPrint.css">
</head>
<body>
    <section id="intro">
        <header class="note_title">스프링 부트</header>
        <ul>
            <li>스프링 부트의 특징
                <pre>
                    ● 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
                    ● 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
                    ● Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
                    ● 손쉬운 빌드 구성을 위한 Starter 종속성 재공
                    ● 스프링 3rd path (외부) 라이브러리 자동 구성
                    ● 메트릭, 상태 확인, 외부 구성같은 프로덕션 준비 기능 제공
                    ● 관례에 의한 간결한 설정
                </pre>
            </li>
            <li>스프링 부트 설치하기
                <pre>
                    1. 이클립스 최상단의 Help 메뉴에서 Eclipse Marketplace 선택하기
                    2. STS (Spring Tool Suite)를 검색한 후에 해당 확장 모듈 설치하기
                </pre>
            </li>
            <li>스프링 부트 프로젝트 생성하기 - 1
                <pre>
                    1. 이클립스 최상단의 File 메뉴의 New 메뉴에서 Spring Starter Project 선택하기
                    2. Name 속성에 프로젝트명을 작성한 후에 해당 프로젝트에 맞게 기본 설정을 세팅한 다음에 Next를 누른다.
                        ● type : 프로젝트 관리도구를 Maven과 Gradle중 선택
                            ○ Maven
                            ○ Gradle
                        ● Packaging : 프로젝트 빌드시 패키지의 형식
                            ○ Jar
                            ○ War
                        ● Java Version : 사용할 Java의 Version 선택
                        ● Language : 사용할 프로그래밍 언어 선택
                            ○ Java
                            ○ Kotlin
                            ○ Groovy
                        ● Group : 프로젝트의 큰 틀 (예시 : com.example)
                        ● Java Version : 프로젝트의 최상위 패키지 (예시 : com.example.demo)
                    3. 프로젝트에 필요한 라이브러리(Dependency)항목들을 선택한 후에 Finish를 누른다.

                    ※ 기본적으로 선택해야 하는 라이브러리 항목
                        1. Web : @*Mapping 어노테이션때문에 필요
                        2. JDBC
                        3. ORM 계열
                        4. DBMS 계열
                    ※ 추천하는 라이브러리 항목
                        ● xxx
                        ● xxx
                        ● xxx
                </pre>
            </li>
            <li>스프링 부트 프로젝트 생성하기 - 2
                <pre>
                    ● start.spring.io로 이동하기
                    ● SNAPSHOT이나 M1은 아직 개발이 미완료된 버전
                    ● Dependencies에서 Spring Web 받기
                </pre>
            </li>
            <li>스프링 부트 설정하기 (+ Jsp 사용 설정)
                <pre>
                    1. 스프링 부트 프로젝트 생성 완료
                    2. Spring Boot에선 기본적으로 JSP VIEW를 지원하지 않기 때문에 pom.xml에 dependency를 추가
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>org.apache.tomcat.embed&lt;/groupId>
                                &lt;artifactId>tomcat-embed-jasper&lt;/artifactId>
                            &lt;/dependency>
                            &lt;dependency>
                                &lt;groupId>jstl&lt;/groupId>
                                &lt;artifactId>jstl&lt;/artifactId>
                                &lt;version>1.2&lt;/version>
                            &lt;/dependency>
                        </pre>
                    3. application.properties에 가서 속성 추가
                        server.port=포트번호
    
                        spring.mvc.view.prefix=/WEB-INF/views/
                        spring.mvc.view.suffix=.jsp
                    4. src/main/java에 컨트롤러 패키지 및 클래스 생성
                    5. src/main에 webapp/WEB-INF/views 폴더 생성 후 해당 폴더에 jsp 파일 생성
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="validation">
        <header class="note_title">유효성 검증</header>
        <ul>
            <li>유효성 검증(validation)이란?
                <pre>
                    ● 오류를 방지하기 위해 미리 검증을 하는 과정
                </pre>
            </li>
            <li>유효성 검증에 대한 주의점
                <pre>
                    ● 검증해야 할 값이 많은 경우 코드의 길이가 길어진다.
                    ● 구현에 따라서 달라질 수도 있겠지만 Service Logic과의 분리가 필요하다.
                    ● 검증하는 코드가 흩어져 있는 경우 검증 위치가 불분명하며 재사용의 한계가 생긴다.
                    ● 구현 방식에 따라 다르겠지만 Validation Logic이 변경되면 참조하는 클래스에서 Logic이 변경되어야 하는 부분이 발생할 수 있다.
                    ● (중요 ★) 별로의 Logic이 필요한 어노테이션들 중에서 다른 VO 객체에서도 반복되는 내용이 있다면 아예 커스텀 어노테이션과 유효성 검증 클래스를 만드는 것이 낫다.
                </pre>
            </li>
            <li>필요 dependency
                <pre>
                    <pre class="prettyprint lang-xml">
                        &lt;dependency>
                            &lt;groupId>org.springframework.boot&lt;/groupId>
                            &lt;artifactId>spring-boot-starter-validation&lt;/artifactId>
                        &lt;/dependency>
                    </pre>
                </pre>
            </li>
            <li>유효성 검증 어노테이션
                <pre>
                    ● 길이 측정
                        ○ @Size(min="최솟값", max="최댓값") : 문자 길이 설정 : int Type 사용불가
                    ● null 또는 공백 여부 확인
                        ○ @NotNull : null 사용불가
                        ○ @NotEmpty : null & "" 사용불가
                        ○ @NotBlank : null & "" & " " 사용불가
                    ● 날짜 확인
                        ○ @Past : 과거 날짜
                        ○ @PastOrPresent : 과거 날짜 또는 오늘 날짜
                        ○ @Future : 미래 날짜
                        ○ @FutureOrPresent : 미래 날짜 또는 오늘 날짜
                    ● 데이터 차이 비교
                        ○ @Max(value="숫자") : 최댓값
                        ○ @Min(value="숫자") : 최솟값
                    ● 별도 Logic에 따른 유효성 검증
                        ○ @Pattern(regexp = "정규식") : 정규식 적용
                        ○ @AssertTure / @AssertFalse : 별도 Logic 적용
                        ○ @Valid : 해당 Object Validation 실행 (= 해당 어노테이션을 붙인 객체에 대해서 검사)
                    ● 형식
                        ○ @Email : 이메일 형식

                    ※ 공통 속성
                        ○ message : validation이 실패할 경우 반환되는 default 메세지
                        ○ payload : 특정 validation을 group을 지정하는 값
                        ○ groups : 사용자가 추가 정보를 위해 전달할 수 있는 값, 주로 심각도를 나타낼 때 사용
                </pre>
            </li>
            <li>사용 예시
                <pre>
                    <pre class="prettyprint lang-java">
                        @AssertTure(message="yyyyMMdd의 형식에 맞지 않습니다.")
                        private String birthday;
                        public String getBirthday() { return birthday; }
                        public void setBirthday(String birthday) { this.birthday = birthday; }

                        //boolean 형식 메소드명은 is로 시작해야 한다.
                        @AssertTrue
                        public boolean isBirthday(){
                            try {
                                LocalDate localDate = LocalDate.parse(getBirthday(), DateTimeFormatter.ofPattern("yyyyMMdd"));
                            } catch (Exception e) {
                                return false;
                            }
                            
                            return true;
                        }
                    </pre>
                </pre>
            </li>
            <li>Custom Validator
                <pre>
                    1. validatior용 패키지를 만든다.
                    2. 해당 패키지에 유효성 검사용 자바 클래스를 만든다.
                    3. 해당 클래스에 ConstraintValidator 인터페이스를 구현한다.
                    4. ConstraintValidator에는 두 값이 필요한데 첫번째는 검증에 필요한 어노테이션의 종류고 두번째는 해당 어노테이션을 통해 들어올 값의 자료형이다.
                    5. initialize 메소드와 isValid 메소드를 오버라이딩한 다음에 필요한 코드를 작성한다.
                        ● initialize :
                            ○ 어노테이션 등록시 값을 초기화하는 메소드
                        ● isValid :
                            ○ 어노테이션 등록시 해당 값을 검증하는 메소드
                            ○ addConstraintViolation(ConstraintValidatorContext 변수, 전달할 메세지, "키 값"...)를 통해서 에러 메세지 전달 가능
                            ○ addConstraintViolation의 키 값들은 ErrorResponse의 errors[].field에 바인딩된다.
                    6. 해당 validatior를 사용할 어노테이션 파일에 가서 @Constraint 어노테이션의 validatedBy 속성의 {} 안에 추가해주면 된다.
                        예시) @Constraint(validatedBy = { BirthdayValidator.class })
                    7. 해당 validatior를 연결시킨 어노테이션을 필요한 곳에 추가해서 사용하면 된다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="exception">
        <header class="note_title">예외 처리</header>
        <ul>
            <li>예외처리 어노테이션
                <pre>
                    ● @ContrllerAdvice : Global 예외처리, 특정 패키지/컨트롤러 예외처리
                        ○ @ContrllerAdvice : @Contrller에 대해 사용하는 어노테이션
                        ○ @RestContrllerAdvice : @RestContrller에 대해 사용하는 어노테이션
                    ● @ExceptionHandler : 특정 컨트롤러의 예외처리
                </pre>
            </li>
            <li>@ExceptionHandler 기본 코드
                <pre>
                    <pre class="prettyprint lang-java">
                        @ExceptionHandler(value=예외종류.class)
                        public ResponseEntity exception(예외종류 e) {
                            //원하는 예외 클래스의 종류를 모를 때는 Exception e로 매개변수를 주고 e.getClass().getName()를 확인해보면 된다.
                            return ResponseEntity.status(HttpStatus.에러코드).body(e.getMessage());
                        }
                    </pre>
                </pre>
            </li>
            <li>작동 방식
                <pre>
                    ● @ContrllerAdvice 어노테이션이 선언된 클래스 내부에 @ExceptionHandler가 선언된 메소드는 모든 컨트롤러에 대해서 적용된다.
                    ● @ContrllerAdvice 어노테이션이 모든 컨트롤러에 대해서 적용되긴 하지만
                      만약 @ContrllerAdvice가 있는 클래스에 있는 @ExceptionHandler와
                      개별의 컨트롤러에 있는 @ExceptionHandler가 같은 exception에 대해서 처리한다고 했을 때,
                      개별의 컨트롤러 쪽에 있는 @ExceptionHandler가 우선적용된다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="filter">
        <header class="note_title">필터</header>
        <ul>
            <li>필터 (filter)
                <pre>
                    ● Web Application에서 관리되는 영역
                    ● 인터셉터는 DispatcherServlet이 실행되기 전에 호출된다.
                    ● Spring Boot Framework에서 클라이언트로부터 오는 요청/응답에 대해서 최초/최종 단계의 위치에 존재한다.
                    ● Filter를 통해서 요청/응답의 정보를 변경할수 있다.
                    ● Spring에 의해서 데이터가 변환되기 전의 순수한 클라이언트의 요청/응답 값을 확인 할 수 있다.
                    ● 유일하게 ServletRequest/ServletResponse 객체를 변환할 수 있다.
                    ● Filter에서는 주로 request/response의 logging 용도나 인증 logic 처리를 한다.
                    ● Filter에서 logic을 처리함으로써 Service Business Logic과 분리한다.
                </pre>
            </li>
            <li>필터 구현하기
                <pre>
                    1. javax.servlet.Filter의 Filter 인터페이스를 구현한 클래스를 만든다.
                    2. 상황에 맞는 메소드를 오버라이딩한다.
                        ○ public void init(FilterConfig filterConfig) : 필터를 웹 콘테이너에 생성 후 초기화할 때 호출되는 메소드
                        ○ public void doFilter(ServletRequest request, SevletResponse response, FilterChain chain) :
                            ○ request, response에 대한 필터링 로직을 작성하는 메소드
                            ○ resquest, response가 체인을 통과할 때 마다 서블릿 컨테이너에서 호출된다.
                            ○ FilterChain으로 연결한다.
                            ○ 필터링 로직을 사용하지 않을 때에는 요청을 servlet으로 보내지 않고 바로 응답하게 한다.
                        ○ public void destroy() : 필터가 웹 콘테이너에서 삭제될 때 호출되는 메소드

                    ● doFilter 예시
                        <pre class="prettyprint lang-java">
                            @Override
                            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
                                ContentCachingRequestWrapper wrappingRequest = new ContentCachingRequestWrapper((HttpServletRequest)request);
                                ContentCachingResponseWrapper wrappingResponse = new ContentCachingResponseWrapper((HttpServletResponse) response);
                        
                                chain.doFilter(wrappingRequest, wrappingResponse);
                        
                                System.out.println(new String(wrappingRequest.getContentAsByteArray(),"UTF-8"));
    
                                System.out.println(new String(wrappingResponse.getContentAsByteArray(),"UTF-8"));
                                
                                wrappingResponse.copyBodyToResponse();
                            }
                        </pre>
                </pre>
            </li>
            <li>필터 적용하기
                <pre>
                    1. @SpringBootApplication이 적용된 클래스에 가서 @ServletComponentScan을 추가한다.
                    2. Filter를 구현한 클래스에 가서 @WebFilter(urlPatterns="url 주소")를 추가한다. (url 주소는 String 배열로 줄 수도 있다.)
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="interceptor">
        <header class="note_title">인터셉터</header>
        <ul>
            <li>인터셉터 (interceptor)
                <pre>
                    ● 컨트롤러에 들어오는 요청 HttpRequest와 컨트롤러가 응답하는 HttpResponse를 가로채는 기능
                    ● Interceptor는 DispatcherServlet이 실행된 후에 호출된다.
                    ● Interceptor에서 logic을 처리함으로써 Service Business Logic과 분리한다.
                </pre>
            </li>
            <li>인터셉터 구현하기
                <pre>
                    1. HandlerInterceptor 인터페이스를 구현한 인터셉터용 클래스를 추가한다.
                    2. 해당 클래스에 @Component 어노테이션을 추가한다.
                    3. 필요한 메소드들을 오버라이딩 한다.
                        ● PreHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
                            ○ 컨트롤러에 진입하기 전에 실행되는 메소드
                            ○ 반환 값이 true일 경우 컨트롤러로 진입하고, false일 경우 진입하지 않는다.
                            ○ Object handler는 진입하려는 컨트롤러의 클래스 객체가 담겨있다.
                        
                        ● PostHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
                            ○ 컨트롤러 진입 후 View가 랜더링 되기 전에 수행되는 메소드
                        
                        ● afterComplete(HttpServletRequest request, HttpServletResponse response, Object object, Exception ex)
                            ○ 컨트롤러 진입 후 view가 랜더링 된 후에 실행되는 메소드
                        
                        ● afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object h)
                            ○ 비동기 요청 시 PostHandle 메소드와 afterCompletion 메소드 대신에 실행되는 메소드
                </pre>
            </li>
            <li>인터셉터 적용하기
                <pre>
                    1. WebMvcConfigurer 인터페이스를 구현한 인터셉터 등록용 클래스를 추가한다.
                        (※ WebMvcConfigurer 인터페이스 : ViewResolver 값을 자동으로 등록해준다.)
                    2. 해당 클래스에 @Configuration 어노테이션을 추가한다.
                    3. 필요한 메소드들을 오버라이딩 한다. (※ InterceptorRegistry 클래스 : 매핑된 인터셉터 목록을 구성하는 데 도움을 주는 클래스)
                        ● public void addInterceptors(InterceptorRegistry registry) : 인터셉터를 등록하는 메소드
                    4. addInterceptors 메소드에서 자신이 생성한 인터셉터 클래스 객체를 등록한다.
                        예시-1)
                            <pre class="prettyprint lang-java">
                                //Lombok의 @RequiredArgsConstructor 추가
                                private final AuthInterceptor authInterceptor;

                                @Override
                                public void addInterceptors(InterceptorRegistry registry) {
                                    registry.addInterceptor(authInterceptor)
                                    .addPathPatterns("/api/test/*") // 해당 경로에 접근하기 전에 인터셉터가 가로챈다. (필수 X)
                                    .excludePathPatterns("/api/service/*"); // 해당 경로는 인터셉터가 가로채지 않는다. (필수 X)
                                }
                            </pre>

                        예시-2)
                            <pre class="prettyprint lang-java">
                                private final AuthInterceptor authInterceptor;
    
                                //MvcConfig는 임의로 만든 인터셉터 등록용 클래스명
                                public MvcConfig(AuthInterceptor authInterceptor) {
                                    this.authInterceptor = authInterceptor;
                                }
    
                                @Override
                                public void addInterceptors(InterceptorRegistry registry) {
                                    registry.addInterceptor(authInterceptor)
                                    .addPathPatterns("/api/test/*") // 해당 경로에 접근하기 전에 인터셉터가 가로챈다. (필수 X)
                                    .excludePathPatterns("/api/service/*"); // 해당 경로는 인터셉터가 가로채지 않는다. (필수 X)
                                }
                            </pre>

                    ※ 인터셉터 객체를 @AutoWired로 받을 수도 있지만 그렇게 되면 순환 참조가 일어날 수도 있다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="async">
        <header class="note_title">비동기 처리</header>
        <ul>
            <li>비동기 처리를 위한 서비스 Class 만드는 방법
                <pre>
                    1. 비동기 처리를 위한 Class 파일을 만든다.
                    2. 비동기 처리를 시킬 메소드를 만든다.
                        ● 필요 어노테이션 : @Async
                        ● 반환타입 : CompletableFuture
                        ● 리턴형식 : return new AsyncResult(실행할_메소드()).completable();
                        ● 예시 )
                            <pre class="prettyprint lang-java">
                                @Async
                                public CompletableFuture run() {
                                    return new AsyncResult(helloWolrd()).completable();
                                }
                                public String helloWolrd() {
                                    try {
                                        Thread.sleep(1000);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    return "Hello World !";
                                }
                            </pre>

                    ※ 비동기 처리를 진행한 결과를 확인하기 위해 서비스의 메소드는 주로 ListenableFuture나 CompletableFuture 형식으로 결과를 반환한다.
                    ※ 주로 return new AsyncResult(결과물) 형식으로 값을 전달한다.
                    ※ completable() 메소드 : ListenableFuture 객체를 CompletableFuture로 변환해서 리턴한다.
                    ※ AsyncResult의 completable() 메소드는 AsyncResult는 기본적으로 ListenableFuture 인터페이스를 구현하고 있기 때문에
                       해당 결과를 CompletableFuture 형태로 바꾸기 위해 사용한다.
                </pre>
            </li>
            <li>비동기 처리 로직 적용 방법
                <pre>
                    1. @SpringBootApplication 어노테이션이 있는 클래스에 가서 @EnableAsync 어노테이션을 추가한다.
                    2. 컨트롤러에 가서 메소드를 작성한다.
                        ● 예외처리를 반드시 추가한다. (예시 : InterruptedException, ExecutionException 등등)
                    3. 해당 메소드의 return을 비동기 처리를 위해 작성한 Service의 @Async 메소드를 반환한다.
                        예시 )
                            <pre class="prettyprint lang-java">
                                @GetMapping("/api/test/async/listenableFuture")
                                public ListenableFuture<Integer> listenableFuture() throws InterruptedException, ExecutionException {
                                    return asyncService.listenableFuture(10000);
                                }
                            </pre>
                </pre>
            </li>
            <li>Custom Thread
                <pre>
                    1. Thread 용으로 사용할 Class를 만든다.
                    2. 반환형이 Executor인 메소드를 만든다.
                    3. ThreadPoolTaskExecutor 필드를 만들어 준다.
                    4. ThreadPoolTaskExecutor의 메소드를 통해서 Thread에 대한 설정을 한다.
                    5. 해당 객체를 return 시켜준다.
                    6. 해당 메소드에 @Bean("Thread명")을 추가해준다.

                    ※ @Async 어노테이션의 name 속성에 Thread Bean의 명시해주면 해당 Thread를 사용하도록 할 수 있다.

                    예시)
                        <pre class="prettyprint lang-java">
                            @Configuration
                            public class AppConfig {
                                @Bean("asyncThread")
                                public Executor asyncThread(){
                                    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
                                    executor.setCorePoolSize(10);
                                    executor.setMaxPoolSize(100);
                                    executor.setQueueCapacity(10);
                                    executor.setThreadNamePrefix("Async-");
                                    return executor;
                                }
                            }
                        </pre>
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="serverToServer">
        <header class="note_title">Server To Server</header>
        <ul>
            <li>서버 호출 방식 (공통)
                <pre>
                    1. 서버를 호출할 서비스 Class를 만든다.
                    2. 원하는 기능을 호출할 메소드를 만든다.
                    3. 해당 메소드의 반환형은 서버를 호출해서 전달받을 결과물의 형태와 같게 지정한다.
                    4. UriComponentsBuilder Class를 통해서 호출할 서버의 URI를 생성한다.
                    5. RestTemplate의 메소드를 호출 방식에 따라 설정하여 서버와 통신하여 결과물 받기
                    6. 해당 결과물을 반환하기
                </pre>
            </li>
            <li>URI 생성
                <pre>
                    <pre class="prettyprint lang-java">
                        URI uri = UriComponentsBuilder
                        .fromUriString("호출할 서버 주소") //예시 : http://localhost:8093
                        .queryParam(name, values) //정의 : uri에서 쓰는 query 값을 설정하는 메소드, 예시 : queryParam("name", "HongGilDong")
                        .path("호출할 path") //예시 : /api/server/hello
                        .encode() //정의 : uri의 기본 문자 set을 UTF-8로 변경
                        .build() //정의 : UriComponents로 변환
                        .toUri(); //정의 : uri로 변환
    
                        //.expand(값) : path의 값에서 중간에 {name}처럼 Path Value를 쓸 수 있는데 그 값을 차례대로 채워준다. ({}가 두 번이면 expand()도 두 번)
                    </pre>

                    ※ RestTemplate의 메소드로 파라미터로 사용될 값에 URI 대신에 String으로 주소를 직접 써도 된다.
                </pre>
            </li>
            <li>RestTemplate를 통한 서버 호출 - GET 방식
                <pre>
                    ● getForObject : GET 요청을 보내고 Java Object로 매핑받아서 반환받음
                        ○ 장점 : 각각의 필드의 대한 값을 개별적으로 볼 수 있다.
                        ○ 기본 형태 : getForObject(URI, ResponseType)
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                RestTemplate restTemplate = new RestTemplate();
                                UserVO result = restTemplate.getForObject(uri, UserVO.class);
                                return result;
                            </pre>
                    ● getForEntity : GET 요청을 보내고 ResponseEntity로 반환받음
                        ○ 장점 : HttpHeader나 HttpBody나 HttpStatus같은 정보들을 볼 수 있음
                        ○ 기본 형태 : getForEntity(URI, ResponseType)
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                RestTemplate restTemplate = new RestTemplate();
                                ResponseEntity&lt;UserVO> result = restTemplate.getForEntity(uri, UserVO.class);
                                return result.getBody();
                            </pre>
                </pre>
            </li>
            <li>RestTemplate를 통한 서버 호출 - POST 방식
                <pre>
                    ● postForLocation : POST 요청을 보내고 java.net.URI 로 반환받음
                        ○ 기본 형태 : postForLocation(URI, Request Object), 결과값 : URI
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                UserVO user
                                    = UserVO.builder()
                                    .name("HongGilDong").age(25).email("hong@naver.com")
                                    .birthday("19970229").phoneNumber("0001112222")
                                    .build();
                                RestTemplate restTemplate = new RestTemplate();
                                URI result = restTemplate.postForLocation(uri, user);
                                return result;
                            </pre>
                    ● postForObject : POST 요청을 보내고 Java Object로 매핑받아서 반환받음
                        ○ 장점 : 각각의 필드의 대한 값을 개별적으로 볼 수 있다.
                        ○ 기본 형태 : postForObject(URI, Request Object, ResponseType)
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                UserVO user
                                    = UserVO.builder()
                                    .name("HongGilDong").age(25).email("hong@naver.com")
                                    .birthday("19970229").phoneNumber("0001112222")
                                    .build();
                                RestTemplate restTemplate = new RestTemplate();
                                UserVO result = restTemplate.postForObject(uri, user, UserVO.class);
                                return result;
                            </pre>
                    ● postForEntity : POST 요청을 보내고 ResponseEntity로로 매핑받아서 반환받음
                        ○ 장점 : HttpHeader나 HttpBody나 HttpStatus같은 정보들을 볼 수 있음
                        ○ 기본 형태 : postForEntity(URI, Request Object, ResponseType)
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                UserVO user
                                    = UserVO.builder()
                                    .name("HongGilDong").age(25).email("hong@naver.com")
                                    .birthday("19970229").phoneNumber("0001112222")
                                    .build();
                                RestTemplate restTemplate = new RestTemplate();
                                ResponseEntity<UserVO> result = restTemplate.postForEntity(uri, user, UserVO.class);
                                return result.getBody();
                            </pre>
                </pre>
            </li>
            <li>RestTemplate를 통한 서버 호출 - PUT 방식
                <pre>
                    ● put : POST 요청을 보내고 java.net.URI 로 반환받음
                        ○ 기본 형태 : put(URI, Request Object)
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                UserVO user
                                    = UserVO.builder()
                                    .name("HongGilDong").age(25).email("hong@naver.com")
                                    .birthday("19970229").phoneNumber("0003334444")
                                    .build();
                                RestTemplate restTemplate = new RestTemplate();
                                restTemplate.put(uri, user);
                            </pre>
                </pre>
            </li>
            <li>RestTemplate를 통한 서버 호출 - DELETE 방식
                <pre>
                    ● delete : POST 요청을 보내고 java.net.URI 로 반환받음
                        ○ 기본 형태 : delete(URI)
                        ○ 사용 예시 :
                            <pre class="prettyprint lang-java">
                                //uri에 .queryParam("name", "HongGilDong") 추가
                                RestTemplate restTemplate = new RestTemplate();
                                restTemplate.delete(uri);
                            </pre>
            </li>
            <li>RestTemplate를 통한 서버 호출 - HTTP Method에 상관없이 호출하기
                <pre>
                    ● exchange : POST 요청을 보내고 java.net.URI 로 반환받음
                        ○ 장점 : Http Header를 수정할 수 있다.
                        ○ 기본 형태 :
                                (1) exchange(URI, HttpMethod, HttpEntity, responseType)
                                (2) exchange(RequestEntity, responseType)
                                ※ RequestEntity와 ResponseEntity가 HttpEntity Class를 상속받고 있다.
                        ○ 사용 예시 - 1 :
                            <pre class="prettyprint lang-java">
                                UserVO user
                                    = UserVO.builder()
                                    .name("HongGilDong").age(25).email("hong@naver.com")
                                    .birthday("19970229").phoneNumber("0001112222")
                                    .build();
                                RequestEntity&lt;UserVO> request = RequestEntity
                                        .post(uri) //요청할 API 서버의 주소 설정
                                        .contentType(MediaType.APPLICATION_JSON) //contentType 설정, org.springframework.http.MediaType
                                        .header("x-authorization","my-header") //헤더 설정
                                        .body(user); //몸체 설정 (= 전달할 데이터)
                                RestTemplate restTemplate = new RestTemplate();
                                ResponseEntity&lt;UserVO> response = restTemplate.exchange(uri, HttpMethod.POST, request, UserVO.class); //org.springframework.core.ParameterizedTypeReference
                            </pre>

                        ○ 사용 예시 - 2 :
                            <pre class="prettyprint lang-java">
                                UserVO user
                                    = UserVO.builder()
                                    .name("HongGilDong").age(25).email("hong@naver.com")
                                    .birthday("19970229").phoneNumber("0001112222")
                                    .build();
                                RequestEntity&lt;UserVO> request = RequestEntity
                                        .post(uri) //요청할 API 서버의 주소 설정
                                        .contentType(MediaType.APPLICATION_JSON) //contentType 설정, org.springframework.http.MediaType
                                        .header("x-authorization","my-header") //헤더 설정
                                        .body(user); //몸체 설정 (= 전달할 데이터)
                                RestTemplate restTemplate = new RestTemplate();
                                ResponseEntity&lt;UserVO> response = restTemplate.exchange(request, new ParameterizedTypeReference&lt;>(){}); //org.springframework.core.ParameterizedTypeReference
                            </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="JUnit">
        <header class="note_title">JUnit</header>
        <ul>
            <li>JUnit
                <pre>
                    ● Java 기반의 단위 테스트를 위한 프레임워크
                    ● 어노테이션 기반으로 테스트를 지원한다.
                    ● Assert를 통하여 (예상, 실제)를 통해 검증한다.
                </pre>
            </li>
            <li>관련 개념
                <pre>
                    ● TDD (Test-driven Development) : 코드의 유지 보수 및 운영 환경에서의 에러를 미리 방지하기 위해서 사용하는 단위 검증 테스트 프레임워크
                    ● 단위 테스트 : 작성한 코드가 기대하는 대로 동작하는지 검증하는 절차
                </pre>
            </li>
            <li>JUnit 특징
                <pre>
                    ○ JUnit에서는 각각의 테스트가 서로 영향을 주지 않고 독립적으로 실행되는 것을 지향한다.
                </pre>
            </li>
            <li>설치 방법
                <pre>
                    ● pom.xml에 dependency 추가
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>org.springframework.boot&lt;/groupId>
                                &lt;artifactId>spring-boot-starter-test&lt;/artifactId>
                                &lt;scope>test&lt;/scope>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>Junit 제공 어노테이션
                <pre>
                    ● @Test
                        ○ 테스트를 수행하는 메소드를 지정하는 어노테이션
                        ○ @Test 단위 마다 필요한 객체를 생성해 지원해준다. 
                    ● @Ignore
                        ○ 테스트를 실행하지 않도록 해준다.
                        ○ 메소드는 남겨두되 테스트에 포함되지 않도록 하려면 @Ignore 어노테이션을 추가한다.
                    ● @Before / @After
                        ○ 테스트 메소드가 실행되기 전/후로 항상 실행되는 메소드를 지정한다.
                    ● @BeforeClass / @AfterClass
                        ○ 해당 클래스에서 각각 한번만 수행되는 메소드를 지정한다.
                        ○ 테스트 메소드의 갯수와 상관없이 반드시 한번만 실행된다.
                </pre>
            </li>
            <li>Junit 기본 사용법
                <pre>
                    1. src/test/java 폴더에 원하는 테스트할 클래스에 대한 클래스를 만든다. (관례 : 만약 테스트할 클래스가 sample.class이면 sampleTest.class를 만든다.)
                    2. 테스트할 메소드를 만들고 해당 메소드에 @Test 어노테이션을 추가한다.
                    3. 해당 메소드 안에서 확인해야할 값은 System.out.println()같은 걸로 출력하는 것이 아니라
                       Assertions.assertEquals(로직을 통해 나온 값, 정상작동시 나와야할 값);처럼 코드를 작성하여 테스트한다.
                </pre>
            </li>
            <li>spring-boot-starter-test의 하위 라이브러리
                <pre>
                    ● JUnit 5 (빈티지 엔진 포함, 이유 : JUnit 4와의 호환성)
                    ● 스프링 테스트 및 스프링 부트 테스트
                    ● AssertJ
                    ● Hamcrest
                    ● Mockito
                    ● JSONassert
                    ● JsonPath
                </pre>
            </li>
            <li>spring-boot-starter-test 제공 어노테이션
                <pre>
                    ● @SpringBootTest
                    ● @WebMvcTest
                    ● @DataJpaTest
                    ● @RestClientTest
                    ● @JsonTest
                    ● @WebFluxTest
                    ● @JooqTest
                    ● @DataLdapTest
                    ● @DataNeo4jTest
                    ● @DataRedisTest
                </pre>
            </li>
            <li>src/test/java 폴더가 보이지 않는 오류 해결법
                <pre>
                    1. 해당 프로젝트 우클릭
                    2. Properties 클릭
                    3. Java Build Path 메뉴 선택
                    4. Order And Export 항목 선택
                    5. src/test/java 폴더를 최상단으로 이동 후 저장
                    6. src/test/java 폴더의 위치를 정상적으로 이동 후 저장
                </pre>
            </li>
            <li>Jacoco
                <pre>
                    ● Java 코드의 코드 커버리지를 체크하는 라이브러리
                    ● 결과를 html, xml, csv로 확인가능하다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="swagger">
        <header class="note_title">Swagger</header>
        <ul>
            <li>Swagger
                <pre>
                    ● 개발한 Rest API를 편리하게 문서화해주는 프로젝트
                    ● 관리 및 제 3자의 사용자가 편리하게 호출해보고 테스트할수 있게 해준다.
                    ※ 주의점 : 운영환경과 같은 외부에 노출되면 안되는 곳에서 사용할땐 주의해야한다.
                </pre>
            </li>
            <li>설치 방법
                <pre>
                    ● pom.xml에 dependency 추가
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>io.springfox&lt;/groupId>
                                &lt;artifactId>springfox-boot-starter&lt;/artifactId>
                                &lt;version>3.0.0&lt;/version>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>Swagger 제공 어노테이션
                <pre>
                    ● @APi : 클래스를 스웨거의 리소스로 표시
                        ○ 사용 예시 )
                            @Api(tags = {"REST API CONTROLLER"}) //루트주소/swagger-ui/index.html에서 해당 컨르롤러 클래스의 이름이 REST API CONTROLLER로 보인다. 
                    ● @ApiOperation : 특정 경로의 오퍼레이션 HTTP 메소드 설명
                        ○ 사용 예시 )
                            @ApiOperation(value = "hello method", notes = "기본적인 인사 GET API")
                            //@ApiOperation 없는 경우 : 메소드명
                            //@ApiOperation 있는 경우 : hello method, note는 /swagger-ui/index.html에서 해당 메소드 클릭시 보이는 주석을 설정한다.
                    ● @ApiParam : 메소드의 파라미터에 대한 메타 데이터 설명 (Controller의 메소드의 파라미터에서 사용)
                        ○ 사용 예시 )
                            @ApiParam(value = "사용자 이름") String name
                            //@ApiParam이 없는 경우 : name - name
                            //@ApiParam이 있는 경우 : name - 사용자 이름
                    ● @ApiResponse : 메소드의 응답 지정
                        ○ 사용 예시 )
                            @ApiResponse(code = 404, message = "not found")
                    ● @ApiModelProperty : 모델의 속성 데이터를 설명 (VO의 필드에서 사용)
                        ○ 사용 예시 )
                            @ApiModelProperty(value = "사용자 이름", example = "steve")
                            //@ApiModelProperty이 없는 경우 : name - name
                            //@ApiModelProperty이 있는 경우 : name - 사용자 이름
                            //value : 해당 필드에 대한 설명
                            //example : /swagger-ui/index.html에서 해당 메소드의 Responses의 Example Value 항목에서 보일 예시 값
                            //required : 필수 여부
                    ● @ApiImplicitParam : 메소드 단위의 오퍼레이션 파라미터를 설명
                    ● @APiImplicitParams : @ApiImplicitParam의 배열을 지정
                        ○ @ApiImplicitParam와 @ApiImplicitParams의 예시 (Controller의 메소드 위에 명시)
                            @ApiImplicitParams({
                                @ApiImplicitParam(name="name", value="사용자 이름"),
                                @ApiImplicitParam(name="age", value="사용자 나이")
                            })
                            //name : 파라미터의 변수명을 의미
                            //value : 해당 파라미터에 대한 설명
                            //required : 필수 여부
                            //dataType : 해당 파라미터의 데이터 타입
                </pre>
            </li>
            <li>기본 사용법
                <pre>
                    1. 해당 프로젝트를 실행한다.
                    2. 브라우저를 키고 localhost:(해당 프로젝트의 서버포트)/swagger-ui/index.html를 입력하여 결과물을 확인한다.

                    ※ 예전에는 @SpringBootApplication Class에 @EnableSwagger2를 추가해야 했으나 현재는 추가하지 않아도 자동적으로 모든 컨트롤러에 Swagger가 적용된다. (일정 버전 이상부터)
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="thymeleaf">
        <header class="note_title">Thymeleaf</header>
        <ul>
            <li>Thymeleaf
                <pre>
                    ● MVC 패턴에 적합하게 설계된 Java 기반의 템플릿 엔진
                    ● 생성할 html 파일의 기본 경로 : src/main/resources/templates
                    ● html 파일의 html 태그에 xmlns:th="http://www.thymeleaf.org"를 추가해서 사용한다.
                </pre>
            </li>
            <li>설치방법
                <pre>
                    ● pom.xml에 dependency 추가
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>org.springframework.boot&lt;/groupId>
                                &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId>
                                &lt;version>2.3.4.RELEASE&lt;/version>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>외부 파일 연결
                <pre>
                    ● 기본 경로 : src/main/resources/static
                    ● 예시) &lt;link th:href="@{/css/index.css}" rel="stylesheet" type="text/css">
                </pre>
            </li>
            <li>데이터 연결하기
                <pre>
                    ● 기본 객체 선택 => th:object="객체"
                        예시)
                            <pre class="prettyprint lang-html">
                                &lt;table>
                                    &lt;tr th:object="${board}">
                                        &lt;td>&lt;span class="no" th:text="{board.no}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="title" th:text="{board.title}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="writer" th:text="{board.writer}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="signdate" th:text="${#temporals.format(board.signdate, 'yyyy-MM-dd HH:mm')}"></span></td>
                                    &lt;/tr>
                                &lt;/table>
                            </pre>

                    ● 반복문 => th:each="객체 : ${리스트}"
                        예시)
                            <pre class="prettyprint lang-html">
                                &lt;table>
                                    &lt;tr th:each="board : ${boardList}">
                                        &lt;!-- 인덱스 값 가져오기 ▼ -->
                                        &lt;!--&lt;td>&lt;span class="no" th:text="{iterState.index}">&lt;/span>&lt;/td>-->
                                        &lt;td>&lt;span class="no" th:text="{board.no}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="title" th:text="{board.title}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="writer" th:text="{board.writer}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="signdate" th:text="${#temporals.format(board.signdate, 'yyyy-MM-dd HH:mm')}"></span></td>
                                    &lt;/tr>
                                &lt;/table>
                            </pre>

                    ● 조건문 - (if-unless) => th:if="${비교대상} [조건] [비교값]"
                        예시)
                        <pre class="prettyprint lang-html">
                            &lt;table>
                                &lt;tr th:each="board : ${boardList}" th:if="${iterState.count} % 2 != 0">
                                    &lt;td>&lt;span class="no" th:text="{board.no}">&lt;/span>&lt;/td>
                                    &lt;td>&lt;span class="title" th:text="{board.title}">&lt;/span>&lt;/td>
                                    &lt;td>&lt;span class="writer" th:text="{board.writer}">&lt;/span>&lt;/td>
                                    &lt;td>&lt;span class="signdate" th:text="${#temporals.format(board.signdate, 'yyyy-MM-dd HH:mm')}"></span></td>
                                &lt;/tr>
                            &lt;/table>
                        </pre>

                    ● 조건문 - (switch-case) => th:switch="조건대상" + th:case=조건값"
                        예시)
                            <pre class="prettyprint lang-html">
                                &lt;div th:switch="${user.grade}">
                                    &lt;p th:case="'normal'">일반 회원&lt;/p>
                                    &lt;p th:case="'vip'">VIP 회원&lt;/p>
                                &lt;/div>
                            </pre>

                    ● 값 설정하기
                        ○ input 태그의 값 지정하기 => th:value
                            예시)
                                &lt;input type="text" id="nickname" th:value="${userInfo.nickname}"/>
                        ○ 속성 값 지정하기 => th:attr
                            예시)
                                &lt;input type="radio" id="YesOrNo" th:attr="checked=${YesOrNo}"/>
                                ※ 실제로 존재하지 않는 임의의 속성을 만들고 싶을 때 사용하는 것이 좋다.
                                ※ action이나 checked같은 속성은 th:action이나 th:checked를 사용할수 있다.
                        ○ 로컬 변수 선언하기 =>  th:with
                            예시)
                                &lt;div th:with="grade=${info.grade},size=${info.size}">&lt;/div>

                    ※ html 태그 없이 조건문을 사용하고 싶은 경우에는 &lt;th:block> 태그를 사용하면 된다.
                    ※ th:text와 th:utext의 차이
                        ▶ th:text → 태그 안의 텍스트 (태그 형식의 텍스트도 일반 텍스트로 취급)
                        ▶ th:utext → 태그 형식의 텍스트가 들어오면 태그로 인식한다.
                </pre>
            </li>
            <li>페이지 include 하기
                <pre>
                    1. include 페이지의 영역에 th:fragment="고유영역명"을 추가한다. (= 조각 생성)
                    2. include 페이지를 적용시킬 페이지에서 각 영역에 th:replace="[파일 경로 :: 고유영역명]"을 추가한다.

                    예시)
                        1. src/main/resources/static/include 폴더의 common.html에서
                           다른 페이지들에 적용시킬 header와 footer 영역을 만든 뒤에
                           각각 th:fragment="header"와 th:fragment="footer"를 추가한다.
                        2. index.html에 가서 include 시킬 임시 영역을 만든다음에
                           각각 th:replace="[include/common::header]"와 th:replace="[include/common::footer]"를 추가한다.
                           => include/common은 include 폴더 안에 있는 common.html을 의미한다.
                </pre>
            </li>
            <li>요소 삭제하기
                <pre>
                    ● 삭제하고 싶은 내용이 있는 태그에 th:remove="속성값"을 추가한다.
                        ○ all: th:remove가 선언된 태그와 그 자식 태그들도 모두 삭제한다.
                        ○ body: th:remove가 선언된 태그는 그대로 두고 자식 태그들만 삭제한다.
                        ○ tag: th:remove가 선언된 태그만 삭제하고 자식 태그들은 그대로 둔다.
                        ○ all-but-first: 첫 번째 자식 태그만 두고 나머지 자식 태그는 모두 삭제한다.
                        ○ none: 아무것도 삭제하지 않고 그대로 둔다. (조건 표현식을 사용하여 조건에 따라 삭제를 할지 말지 결정할 때 사용)
                </pre>
            </li>
            <li>페이지 하이퍼링크 생성하기 (th:href="@{경로}")
                <pre>
                    ● 단순한 URL
                        예시 ) &lt;a th:href="@{/main}">메인 화면 이동&lt;/a>

                    ● 쿼리 파라미터 → () 에 있는 부분은 쿼리 파라미터로 처리
                        예시 ) &lt;a th:href="@{/main(paramA=${paramA}, paramB=${paramB})}">메인 화면 이동&lt;/a>
                                => /main?paramA=dataA&paramB=dataB
                    
                    ● 경로 변수 → URL 경로상에 변수가 있으면 () 부분은 경로 변수로 처리
                        예시 ) &lt;a th:href="@{/main/{param1}/{param2}(param1=${param1}, param2=${param2}))}">메인 화면 이동&lt;/a>
                                => /main/dataA/dataB

                    ※ 쿼리 파라미터와 경로 변수를 동시에 사용할 수도 있다.
                </pre>
            </li>
            <li>타임리프의 유틸
                <pre>
                    ● #message : 메시지, 국제화 처리
                    ● #uris : URI 이스케이프 지원
                    ● #dates : java.util.Date 서식 지원
                    ● #calendars : java.util.Calendar 서식 지원
                    ● #temporals : java.time.LocalDateTime 서식 지원 (Java 8, 타임리프 권장)
                        ○ ${#temporals.format(형식을 지정할 LocalDateTime형의 데이터, 형식)}
                    ● #numbers : 숫자 서식 지원
                    ● #strings : 문자 관련 편의 기능
                    ● #objects : 객체 관련 기능 제공
                    ● #bools : boolean 관련 기능 제공
                    ● #arrays : 배열 관련 기능 제공
                    ● #lists , #sets , #maps : 컬렉션 관련 기능 제공
                    ● #ids : 아이디 처리 관련 기능 제공
            </li>
        </ul>
    </section>

    <br>

    <section id="ObjectMapper">
        <header class="note_title">ObjectMapper</header>
        <ul>
            <li>ObjectMapper
                <pre>
                    ● Java 객체를 Json으로 직렬화 하거나 또는 Json 데이터를 Java 객체에 역직렬화 하는 기능을 수행하는 클래스
                    ● 최근 API 서비스가 아니더라도 복잡한 구조의 데이터를 쉽게 서로 주고 받을 수 있게 하기 위해
                      View 영역과 백엔드가 통신을 할 때 Json을 많이 이용하기 때문에 많이 사용하게 된 클래스
                </pre>
            </li>
            <li>사용 조건 (pom.xml의 dependency)
                <pre>
                    ● Spring의 경우
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>
                                &lt;artifactId>jackson-databind&lt;/artifactId>
                                &lt;version>2.9.8&lt;/version>
                            &lt;/dependency>
                        </pre>
                    ● Spring Boot의 경우
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>org.springframework.boot&lt;/groupId>
                                &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>기본 사용 방법
                <pre>
                    ※ ObjectMapper objectMapper = new ObjectMapper();

                    ● Java Object → Json
                        UserVO user = UserVO.builder().name("HongGilDong").age(25).email("hong@naver.com").birthday("19970229").phoneNumber("0001112222").build();
                        String javaObjectToJson = objectMapper.writeValueAsString(user);
                    ● Json → Java Object
                        String jsonString = "{\"name\":\"jsonString\",\"age\":25,\"email\":\"jsonString@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        UserVO jsonToJavaObject = objectMapper.readValue(jsonString, UserVO.class);
                    ● JSON 배열을 Java List에 매핑하기
                        String jsonStringA = "{\"name\":\"jsonStringA\",\"age\":25,\"email\":\"jsonStringA@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        String jsonStringB = "{\"name\":\"jsonStringB\",\"age\":25,\"email\":\"jsonStringB@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        String jsonArray = "["+jsonStringA+","+jsonStringB+"]";
                        List&lt;UserVO> users = objectMapper.readValue(jsonArray, new TypeReference&lt;List&lt;UserVO>>(){});
                    ● JSON 데이터를 Map에 매핑하기
                        String jsonStringForMap = "{\"name\":\"jsonStringForMap\",\"age\":25,\"email\":\"jsonStringForMap@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        HashMap&lt;String, Object> map = objectMapper.readValue(jsonStringForMap, new TypeReference&lt;HashMap&lt;String,Object>>(){});

                    ※ 예외사항 (@Builder 어노테이션을 사용하는 경우의 VO)
                        예시)
                            <pre class="prettyprint lang-java">
                                @Getter
                                @Setter
                                @Builder(builderClassName = "UserVOBuilder", toBuilder = true)
                                @JsonDeserialize(builder = UserVO.UserVOBuilder.class)
                                public class UserVO {
                                    private String name; //이름
                                    private int age; //나이
                                    private String email; //이메일
                                    private String phoneNumber; //핸드폰번호
                                    private String birthday; //생년월일
                                    
                                    @JsonPOJOBuilder(withPrefix = "") public static class UserVOBuilder { 
                                        
                                    }
                                }
                            </pre>
                </pre>
            </li>
            <li>추가 사용 방법
                <pre>
                    ※ ObjectMapper objectMapper = new ObjectMapper();

                    ● 역직렬화 실행시 존재하지 않는 필드 무시 설정
                        예시)
                            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 없는 필드로 인한 오류 무시
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="modelMapper">
        <header class="note_title">ModelMapper</header>
        <ul>
            <li>MbjectMapper
                <pre>
                    ● xxx
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="responseEntity">
        <header class="note_title">ResponseEntity</header>
        <ul>
            <li>ResponseEntity Class
                <pre>
                    ● 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스
                    ● HttpEntity를 상속받아서 만들어진 클래스 (HttpEntity = HttpHeaders + HttpBody)
                    ● ResponseEntity = HttpStatus + HttpHeaders + HttpBody + a
                        ○ HttpHeaders : HTTP의 request 또는 response에 대한 부가적인 정보 (예시 : 전달받은 데이터 형식)
                        ○ HttpBody : HTTP의 request 또는 response가 전송하는 데이터 (본문), 존재하지 않는 경우도 있다. (예시 : GET 방식)
                        ○ HttpStatus : 클라이언트의 요청이 성공적으로 처리되었는지 상태를 알려주는 고유의 값 (예시 : 405)
                    ● ResponseEntity 객체가 반환되면 Json이나 Xml 등 다른 형식으로 직렬화가 된다.
                </pre>
            </li>
            <li>전달 형식
                <pre>
                    ● 1번 형태 (한 번에 생성하는 방식)
                        ○ 1-1
                            return new ResponseEntity&lt;반환할 타입>(전달할 body, 전달할 header, HttpStatus.코드명);
                            //예시 : return new ResponseEntity&lt;UserVO>(user, headers , HttpStatus.BAD_REQUEST);
                        ○ 1-2
                            return new ResponseEntity&lt;반환할 타입>(전달할 body, 전달할 header, HttpStatus.valueOf(코드값));
                            //예시 : return new ResponseEntity&lt;UserVO>(user, headers , HttpStatus.valueOf(400));
                    ● 2번 형태 (오류메소드를 사용하여 바로 반환하는 방식)
                        ○ 2-1
                            return ResponseEntity.오류메소드명(객체명); //매개변수가 있는 ok 메소드는 ResponseEntity 형태로 return
                            //예시 : return ResponseEntity.badRequest(user);
                        ○ 2-2
                            return ResponseEntity.오류메소드명().build(); //매개변수가 없는 ok 메소드는 BodyBuilder 형태이기 때문에 build()를 통해서 ResponseEntity 변환 후 return
                            //예시 : return ResponseEntity.ok().build();
                    ● 3번 형태 (각각의 파라미터를 설정해서 개별 설정하는 방식)
                        ○ 사용 예시 )
                            <pre class="prettyprint lang-java">
                                HttpHeaders HttpHeaders변수명 = new HttpHeaders(); //org.springframework.http.HttpHeaders
                                HttpHeaders변수명.set("속성명", "값");
    
                                VO클래스 vo변수명 = UserVO.builder().필드명("값").build();
                            
                                return ResponseEntity.오류메소드명()
                                        .headers(HttpHeaders변수명)
                                        .body(vo변수명)
                                        .status(HttpStatus.코드명);
                            </pre>
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="annotation">
        <header class="note_title">어노테이션 목록</header>
        <ul>
            <li>목록
                <pre>
                    ● @SpringBootApplication
                    ● @JsonProperty
                    ● @JsonNaming
                    ● @JsonInclude
                </pre>
            </li>
            <li>스프링 부트
                <pre>
                    ● @SpringBootApplication : 해당 클래스를 Spring Boot Application으로 설정
                </pre>
            </li>
            <li>컨트롤러 관련 어노테이션
                <pre>
                    ● @RestController
                        ○ 정의 : 해당 클래스를 REST API를 제공하는 컨트롤러로 설정
                        ○ 요약 : @Controller + @ResponseBody
                        ※ 주의점 :
                            @RestController를 붙이게 되면 해당 컨트롤러는 view 페이지를 반환하는게 아닌 응답본문 객체를 반환하는 것이기 때문에
                            Ajax같은 기능에 대한 메소드들이 모여있는 클래스에서 사용하는 것이 좋다.

                    ● @GetMapping : Http Get Method URL 주소 매핑
                    ● @PostMapping : Http Post Method URL 주소 매핑
                    ● @PutMapping : Http Put Method URL 주소 매핑
                    ● @DeleteMapping : Http Delete Method URL 주소 매핑

                    ● @Valid : POJO Java class의 검증
                </pre>
            </li>
            <li>Lombok 어노테이션
                <pre>
                    ● @Data : 종합 선물 세트
                        ○ @Data
                            = @toString  + @EqualsAndHashCode
                            + @Getter  + @Setter
                            + @NoArgsConstructor + @RequiredArgsConstructor  + @AllArgsConstructor
                        ○ 효과가 너무 강하여 왠만하면 @Data 어노테이션보다는 필요한 어노테이션만 따로 설정하는 것이 좋다.

                    ● @Getter : getter 메소드를 자동으로 만들어준다. 
                    ● @Setter : setter 메소드를 자동으로 만들어준다.

                    ● @Value : 불변하는 특성을 가진 객체를 만드려고 할 때 사용한다.

                    ● @NoArgsConstructor : 파라미터가 없는 생성자를 생성해준다.
                        ○ final이 붙어있는 경우에는 필드를 초기화 할 수 없기 때문에 생성자를 만들 수가 없어서 에러가 발생한다.
                        ○ final이 붙어있는 경우에는 @NoArgsConstructor(force = true) 옵션을 이용해서 강체로 초기화시켜서 생성자를 만드는 방법을 사용한다.
                        ○ @NonNull 같이 필드에 제약조건이 설정되어 있는 경우, 생성자 내에 null-check 로직이 생성되지 않는다.
                    ● @RequiredArgsConstructor : 추가 작업을 필요로 하는 필드에 대한 생성자를 생성
                        ○ 초기화 되지 않은 모든 final 필드와 @NonNull같은 validator로 마크돼있는 모든 필드들에 대한 생성자를 자동으로 생성해준다.
                        ○ validator 어노테이션이 붙어있는 필드에 대하여 만들어진 생성자는 자동적으로 해당 어노테이션에 대한 검증요소가 추가된다.
                    ● @AllArgsConstructor : 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
                        ○ @NoArgsConstructor + @RequiredArgsConstructor
                    ● @Builder : 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
                        ○ @AllArgsConstructor 또는 @RequiredArgsConstructor
                        ○ @Builder 이외의 생성자 어노테이션들은 필드를 선언한 순서대로 생성자의 파라미터를 만들기 때문에
                          만약 VO Class에서 두 필드의 선언 순서를 바꿨는데 두 필드가 자료형까지 같다면 오류가 발생하지 않기 때문에
                          추후에 문제가 발생해도 모를 확률이 크기때문에 @Builder를 사용하는 것이 좋다.
                        ○ 기본 사용 예시
                            <pre class="prettyprint lang-java">
                                UserVO tempUser
                                = UserVO.builder()
                                    .name("홍길동")
                                    .age(25)
                                    .email("hong@naver.com")
                                    .phoneNumber("0001112222")
                                    .birthday("19970229")
                                    .build();
                            </pre>
                        ○ @Builder(toBuilder = true) 사용 예시 : builder 패턴으로 생성된 객체의 일부 값을 변경한 새로운 객체 생성
                            <pre class="prettyprint lang-java">
                                UserVO userA
                                = UserVO.builder()
                                    .name("A")
                                    .age(25)
                                    .email("hong@naver.com")
                                    .phoneNumber("0001112222")
                                    .birthday("19970229")
                                    .build();

                                    //userA에서 name/age 값만 변경된 새로운 객체를 생성 
                                    BuilderVO b2 = b.toBuilder().name("B").age(24).build();
                            </pre>
                        ○ @Builder.Default 사용 예시 :
                            <pre class="prettyprint lang-java">
                                private String name; //기본 값 null
                                @Builder.Default private String job="programmer"; //기본 값 부여
                            </pre>
                        ○ @Singular 옵션 사용 예시 :
                            <pre class="prettyprint lang-java">
                                //vo
                                @Singular("hobbyList") private List&lt;String> hobbyList;
                                //생성 영역
                                UserVO userC
                                = UserVO..builder() .hobbyList("game") .hobbyList("read book") .hobbyList("listen music") .build();
                            </pre>


                    ● @ToString : 해당 VO Class의 모든 필드를 출력하는 toString 메소드를 생성한다.
                        ○ includeFieldNames 옵션 : includeFieldNames=false 옵션을 사용하면 필드의 이름을 출력하지 않는다.
                        ○ exclude 옵션 : exclude="필드명" 옵션을 사용하면 해당 필드를 제외한다. 여러개면 {} 안에 명시
                            ※ ToString에서 제외하고 싶은 필드에 직접 @ToString.Exclude을 추가해도 된다.
                        ○ of 옵션 : of={"필드1", "필드2", ...} 옵션을 사용하면 특정 필드를 포함하게 한다.
                        ○ callSuper 옵션 : callSuper=true 옵션을 사용하면 부모 클래스의 toString()을 호출한다.
                    ● @EqualsAndHashCode - hashcode와 equals 메소드를 생성한다.
                        ○ 불변 클래스를 제외하고는 아무 파라미터 없는 @EqualsAndHashCode 어노테이션은 사용하지 않는 것이 좋다.
                        ○ 항상 @EqualsAndHashCode(of={“필드명시”}) 형태로 동등성 비교에 필요한 필드를 명시하는 형태로 사용한다.
                        ○ equals :  두 객체의 내용이 같은지, 동등성(equality) 를 비교하는 연산자
                        ○ hashCode : 두 객체가 같은 객체인지, 동일성(identity) 를 비교하는 연산자
                        ○ callSuper 옵션
                            ▶ callSuper=true : 부모 클래스 필드 값들도 동일한지 체크
                            ▶ callSuper=false (기본값) : 자신 클래스의 필드 값만 체크
                    ● @Log / @Slf4j (★) / @Log4j2 : log 기능을 바로 사용해줄 수 있게 해준다.
                    ● @NonNull : null 값 체크
                    ● @Cleanup : I/O 작업이나 JDBC 작업시 try-catch-finally문의 finally에서 close()를 사용해야 하던 번거로움을 줄여준다.
                        예시) @Cleanup Connection con = DriverManager.getConnection(url, user, password);
                    ● @SneakyThrows(예외오류명.class) : throws나 try-catch문의 catch를 통한 번거로운 예외 처리 생략가능
                    ● @Synchronized : 동기화

                    ※ Lombok 설치 방법
                        1. pom.xml에 dependency 추가
                            <pre class="prettyprint lang-xml">
                                &lt;dependency>
                                    &lt;groupId>org.projectlombok&lt;/groupId>
                                    &lt;artifactId>lombok&lt;/artifactId>
                                    &lt;version>1.18.16&lt;/version>
                                    &lt;scope>provided&lt;/scope>
                                &lt;/dependency>
                            </pre>
                        2-A-1. cmd를 켜서 cd C:\Users\사용자명\.m2\repository\org\projectlombok\lombok\lombok버전 실행
                        2-A-2. java -jar lombok.jar 실행 (버전이 있는 경우 java -jar lombok-1.18.16.jar)
                        2-B-1. 파일 탐색기를 열고 C:\Users\사용자명\.m2\repository\org\projectlombok\lombok\lombok로 이동
                        2-B-2. lombok.jar 파일 실행
                        3. IDEs 목록에 사용하는 STS(eclipse)를 선택 (안 보이면 Specify location 버튼으로 찾기)
                        4. Install / Update 클릭
                        5. Install Successful이 출력되면 성공 (Quit Installer는 단순 종료 버튼)

                    ※ Lombok 어노테이션 추가 위치
                        ● 클래스 위
                        ● 필드 위

                    ※ @Getter / @Setter에 필드를 포함시키지 않는 방법
                        ● @Geeter(AccessLevel.None)
                        ● @Setter(AccessLevel.None)

                    ※ 생성자 어노테이션을 고유 이름으로 만들기
                       1. 해당 VO Class에 생성자 어노테이션을 추가한다.
                       2. 해당 어노테이션에 staticName="원하는 이름" 옵션을 추가한다.
                       3. 해당 Class에 대한 생성자는 private로 만들어진다.
                       4. private로 만들어진 생성자를 return 시키는 public static 생성자가 만들어진다. (생성자명은 옵션에 명시한 이름)

                    ※ 주의점
                        ● static 필드에도 @Getter / @Setter 적용이 가능하다.
                        ● enum에도 @Getter를 사용할 수 있다.
                        ● enum에는 @Setter를 사용할 수 없다.
                        ● 생성자 어노테이션에서 static 필드는 제외된다.
                        ● 생성자 어노테이션 사용 시 생성자의 파라미터의 순서는 해당 VO Class에서 필드를 선언한 순서와 같다. (주의 필요)
                        ● 생성자 어노테이션 사용시 기본값은 public이지만 필요로 따라서 접근 제한자를 설정해야 한다.
                        ● 생성자 어노테이션도 (access =AccessLevel.PROTECTED)처럼 기본 접근 제한자를 선택할 수 있는 옵션이 존재한다.
                        ● 왜인지는 모르겠는데 @Builder를 사용할 때 커스텀 어노테이션이 있으니까 오류가 생긴다.
                </pre>
            </li>
            <li>Custom Annotation
                <pre>
                   1. 어노테이션용 패키지를 만든다.
                   2. 해당 패키지에서 어노테이션 파일을 만든다. (New에 보면 어노테이션이 있다.)
                   3. 어노테이션 제작 시 필요한 항목들을 선택해서 만들거나 아니면 아래의 기본적인 값들을 복사 및 붙여넣기 한다.
                        기초 import 목록 )
                            <pre class="prettyprint lang-java">
                                import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
                                import static java.lang.annotation.ElementType.CONSTRUCTOR;
                                import static java.lang.annotation.ElementType.FIELD;
                                import static java.lang.annotation.ElementType.METHOD;
                                import static java.lang.annotation.ElementType.PARAMETER;
                                import static java.lang.annotation.ElementType.TYPE_USE;
                                import static java.lang.annotation.RetentionPolicy.RUNTIME;
                                
                                import java.lang.annotation.Documented;
                                import java.lang.annotation.Retention;
                                import java.lang.annotation.Target;
                                
                                import javax.validation.Constraint;
                                import javax.validation.Payload;
                            </pre>
                        기초 어노테이션 목록 )
                            <pre class="prettyprint lang-java">
                                @Documented
                                @Constraint(validatedBy = { })
                                @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
                                @Retention(RUNTIME)
                            </pre>
                        기초 속성 목록 )
                            <pre class="prettyprint lang-java">
                                String message() default "{javax.validation.constraints.Email.message}";
                                Class&lt;?>[] groups() default { };
                                Class&lt;? extends Payload>[] payload() default { };
                                String regexp() default ".*";
                            </pre>
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="study_api_integration">
        <header class="note_title">API 연동하기</header>
        <ul>
            <li>네이버 API
                <pre>
                    1. 네이버 메인 최하단의 "Developers" 메뉴 목록에서 "네이버 개발자" 센터 메뉴 클릭하기
                    2. 최상단의 "Application" 메뉴의 "애플리케이션 등록" 메뉴를 클릭한다.
                    3. 각 항목들을 설정하고 등록하기 버튼을 누른다.
                    4. 각 API의 가이드 문서를 보고 사용하면 된다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="reference">
        <header class="note_title">참조 목록</header>
        <ul>
            <li>Talend API Tester
                <pre>
                    ● 요청에 대한 테스트를 진행할 수 있는 크롬 앱
                    ● 크롬 앱스토어에서 설치 가능
                    ● 비슷한 프로그램 : 포스트맨
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="xxx">
        <header class="note_title">xxx</header>
        <ul>
            <li>xxx
                <pre>
                    ● xxx
                </pre>
            </li>
        </ul>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu" onchange="move_section()">
                <option value="intro">스프링 부트</option>
                <option value="validation">유효성 검사</option>
                <option value="exception">예외 처리</option>
                <option value="filter">필터</option>
                <option value="interceptor">인터셉터</option>
                <option value="async">비동기 처리</option>
                <option value="serverToServer">Server To Server</option>
                <option value="JUnit">JUnit</option>
                <option value="swagger">Swagger</option>
                <option value="thymeleaf">Thymeleaf</option>
                <option value="ObjectMapper">ObjectMapper</option>
                <option value="modelMapper">ModelMapper</option>
                <option value="responseEntity">ResponseEntity</option>
                <option value="annotation">어노테이션 목록</option>
                <option value="study_api_integration">API 연동하기</option>
                <option value="reference">참조 목록</option>
            </select>
        </section>
    </div>

    <!-- 모달 영역 시작 -->
    <div id="xxx" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <span class="modal_title">xxx</span>
            <div class="modal_content">
                <p style="margin-left: 30px;">
                    xxx
                </p>
            </div>
        </div>
    </div>
    <!-- 모달 영역 종료 -->

    <!--code pretty print -->
    <script src ="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

    <script>
        prettyPrint();
    </script>
</body>
</html>