---
layout: post
title:  "쿼리 튜닝"
date:   2024-02-09 15:38:00 +0900
categories:  SQL
published: false
---

### 실행계획을 적극적으로 확인해보자.

- 실행할 쿼리 앞에 EXPLAIN 키워드를 붙여서 실행하면 해당 쿼리 실행 계획을 알 수 있다.
- 실행 계획에는 실행할 쿼리가 실행될 때에 관여되는 사항들에 대한 정보가 출력된다.
- 이를 통해서 쿼리의 어떤 부분에서 자원을 많이 잡아먹는지 파악할 수 있다.

### CURRENT_DATE 보다 리터럴을 사용하여 날짜 비교를 하자
다른 프로시저의 경우, 테이블에 인덱스 적용이 잘 되어있었고 쿼리에서도 단순히 where 절로 날짜 타입을 조건으로 걸어 검색했으나 인덱스를 타지 않았다. CURRENT_DATE에 대한 참조 때문에 쿼리 캐시가 결과를 캐싱하지 못했던 것이었다. 리터럴로 변경하여 캐싱되도록 처리하니 642ms → 74ms로 속도가 개선되었다. =, >=, <=처럼 범위 비교할 때 부등호 왼쪽에 함수를 적용하면 인덱스를 타지 않는다는 것은 알고 있었으나, 오른쪽에 CURRENT_DATE 같은 함수를 써도 인덱스 타는데 영향을 미칠 수 있다는 것은 이번에 알게 되었다.

### 인덱스 컬럼에 IN이 인덱스를 타지 않는다면 range_optimizer_max_mem_size을 확인하자
range_optimizer_max_mem_size는 range optimizer로 이용할 수 있는 메모리를 조절하는 시스템 변수이다. 기본 값은 mysql ver 5.7.12 이상인 경우 8M, 5.7.11 이하인 경우 1.5M이며 아래 방법으로 해당 변수를 임의로 세팅할 수 있다.

#### range_optimizer_max_mem_size 확인
SHOW VARIABLES LIKE '%mem%';

#### 해당 세션에서만 적용 & 메모리 제한 없음 (no limit)
SET session range_optimizer_max_mem_size=0;

#### 글로벌 적용 & 123456bytes 로 메모리 제한
SET range_optimizer_max_mem_size=123456;
지정한 메모리를 초과할 경우, 내부적으로 range 함수 대신 다른 방법으로 데이터를 탐색한다. 이때 full scan이 이뤄질 수도 있으며 이는 성능을 저하시키기 때문에, range_optimizer_max_mem_size를 조절하는 것도 성능 개선의 한 가지 방법일 수 있다. 그런데 range_optimizer_max_mem_size를 충분한 크기로 조절해도 (혹은 0으로 설정했거나) 인덱스를 타지 않을 수 있다. 이는 조건에 일치하는 레코드가 너무 많아 MySQL 옵티마이저가 range scan을 포기하고 full scan을 하는 것일 수 있다. (내 경우가 이랬음) 이런 경우 조건 범위를 줄이거나 다른 방법으로 성능 개선하도록 하자.

### WHERE절에서의 CASE문을 사용하는 것은 조심해야 한다.

- CASE문에서 사용되는 컬럼은 인덱스가 걸려있어도 인덱스를 타지 않는다.
- OR 키워드를 통해서 대체할 수 있다.

### 현재 선택된 테이블이 가장 최선의 선택일까?

- 요구사항에 따라서 각 경우마다 다양한 테이블들이 사용될 것이다.
- 정말 적을 떄는 1개로 끝나는 경우도 있겠지만,  
보통은 여러 개의 테이블이 함께 사용될 것이다.
- 실행할 쿼리에 명시된 테이블들이 현재 요구사항에 알맞는 최선의 선택인지 항상 확인해봐야 한다.
- 이를 위해서는 테이블 구조를 확실히 파악하고 있어야 한다.

### 서브 쿼리가 늘 나쁜 것은 아니다.

- 서브 쿼리가 경우에 따라서는 과한 호출량을 만들어 낼수 있는 것은 사실이다.
- 다만 용량이 작거나 구조가 잘 만들어진 테이블의 경우에는 어설프게 FROM절쪽에 옮겨서  
JOIN 하는 것보다 서브 쿼리로 호출하는 것이 빠른 경우도 있다.
- 실제로 실행 계획을 통해서 예상 I/O를 확인하다보면 JOIN보다 서브 쿼리가 더 효율적인 경우가 존재한다.
- 물론 JOIN으로 뺴는 게 INNER JOIN으로 뺸다면 더 빨라지는 경우가 많긴 하겠지만  
항상 그런 경우만 있다는 보장은 없다.

### 필요한 속성만 조회하자.

- SELECT문에 *를 사용할 경우 해당 테이블에 있는 모든 속성에 대해서 조회할 수 있다.
- 그러나 필요하지도 않는 속성을 조회하게 되면 불필요한 자원 낭비가 발생한다.
- 또한, 가독성이 떨어지기 때문에 추후 유지 보수가 어려울 수 있다.

### 데이터는 전체가 아닌 일부만 가져오자.

- 당연한 얘기이긴 하지만 SELECT문을 실행하여 50건의 데이터를 가져온다고 가정했을 떄,  
전체를 가져와서 50건을 탐색하는 것보다는  
처음부터 50건만 검색하도록 하는 것이 성능도 올라가고 자원도 절약된다.
- DBMS에 따라 적용 방법이 다르다.
- 페이징과도 연관이 있다.

### DISTINCT 키워드를 통한 중복 제거 방식은 피하자.

- 결과 데이터의 중복을 제거하기 위해 DISTINCT를 사용하면  
추가적인 처리 부담이 발생하여 성능 저하가 발생할 수 있다.
- DISTINCT보다는 GROUP BY를 통해 중복된 값을 그룹화하는 방식을 사용하면 된다.
- GROUP BY를 통한 중복 제거는 필요한 컬럼만 선택해서 그룹화할 수 있다는 장점이 있다.

### 대규모 쿼리는 사용량이 적은 시간대에 실행하는 것이 좋다.

- 기본적으로 각 서비스마다 사용량이 많은 시간과 적은 시간이 있다.
- 서비스의 사용량이 많은 시간은 당연히 데이터베이스 서버에도 대량의 트래픽이 발생한다.
- 대용량 트래픽이 발생하는 시간대에 대규모 쿼리를 실행하게 되면  
데이터베이스 서버에도 영향이 크지만,  
결과적으로는 시스템 전체의 성능을 떨어뜨려 다른 사용자에게 불편을 줄 수도 있으니  
대규모 쿼리는 사용량이 적은 시간대에 실행하는 것이 좋다.

### 조인은 필요한 만큼만 하자.

- 당연한 얘기지만 효율적인 서비스를 위해서는 데이터베이스 조회도 효율적으로 해야 한다.
- 컬럼도 필요한 만큼만 명시해야 하며, 조인할 테이블도 필요한 만큼만 해야한다.
- 조인되는 테이블이 늘어날 수록 조회 대상이 되는 컬럼의 수는 덧셈이 아닌 곱셈이 되는 것이기 때문에 조인되는 테이블은 매우 신중히 결정해야 한다.

### WHERE절에서 좌항에 함수를 사용하는 것은 지양하자.

- WHERE에서 인덱스를 적용하고 싶은 컬럼이 존재한다면 해당 컬럼은 함수를 사용하게 하면 안 된다.
- 기본적으로 좌항에 함수를 사용하게 되면 인덱스를 적용받지 못 한다.

### 인덱스는 필요한 인덱스만 만들어야 한다.

- 인덱스는 쿼리의 조회 속도를 올려주는 분명 고마운 존재인 것은 맞다.
- 그러나 인덱스는 기본적으로 기존에 있던 데이터를 통해서 만들어지기 떄문에  
실제로 물리적인 공간을 차지한다.
- 인덱스가 많아질 수록 물리적인 공간을 많이 차지하게 되니  
요구사항을 정말 철저히 분석하여서 필요한 인덱스만 생성해야 한다.

### 인덱스는 함수에도 사용할 수 있다.

- 현재 이 게시글을 작성하고 있는 시점에는 비슷비슷한 소규모 프로젝트만 하다보니  
정확하게 알고 있는 것은 아니지만 주로 인덱스는 컬럼을 기준으로만 생성했다.
- 그러나 인덱스는 컬럼에만 걸 수 있는 게 아닌 함수에도 걸 수 있다.
- 예시 : `CREATE INDEX name_replace_dot ON user_info ((REPLACE(NAME, '.', '')));`

### Virtual Column을 사용해 보자.

- 기본적으로 WHERE절에서 좌항에 함수를 사용하면 인덱스를 타지 않는다.
- 함수를 통해 가공된 원본 컬럼의 값이 저장된다.
- INSERT 시에 실제로 값을 넣을 수는 없다.
- 원본 컬럼이 UPDATE되면 Virtual Column도 함께 UPDATE 된다.
- 가상 컬럼이나 임시 컬럼 등으로 부른다.
- 예시 (Virtual Column 추가)
    - `ALTER TABLE user_info ADD COLUMN name_replace_dot VARCHAR(30) GENERATED ALWAYS AS (REPLACE(name, '.', '')) STORED;`
- 예시 (Virtual Column에 대한 인덱스 추가)
    - `CREATE INDEX name_replace_dot ON user_info (name_replace_dot);`


{% highlight sql %}
{% endhighlight %}

- [[번역] MySQL 쿼리 속도를 높이고 실행 속도를 줄이는 10가지 방법](https://kkeolmusae.tistory.com/94)
- [[MySql] 쿼리 속도 개선 (Virtual Column 및 인덱스 적용) Or 절 여러개 예시](https://mingg123.tistory.com/257)
- [쿼리 속도 향상을 위한 방법들](https://compogetters.tistory.com/89)
- [[MySQL] MySQL DB에서 Select 쿼리가 늦어지는 이유](https://peterica.tistory.com/390)
- [[번역] 속도와 성능을 위해 MySQL 쿼리를 최적화하는 방법](https://kkeolmusae.tistory.com/93)
- [[SQL] 쿼리 속도 향상을 위한 방법](https://velog.io/@piczo/SQL-%EC%BF%BC%EB%A6%AC-%EC%86%8D%EB%8F%84-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95)
- [MySQL IN절을 통한 성능 개선 방법](https://jojoldu.tistory.com/565)
- [[MySQL/Java] DB 쿼리 성능개선 (2) 랭킹 조회 속도 개선하기 (5s ➡️ 1s대로 줄이기!)](https://erinh.tistory.com/entry/MySQLJava-DB-%EC%BF%BC%EB%A6%AC-%EC%84%B1%EB%8A%A5%EA%B0%9C%EC%84%A0-2-%EB%9E%AD%ED%82%B9-%EC%A1%B0%ED%9A%8C-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-5s-%E2%9E%A1%EF%B8%8F-1s%EB%8C%80%EB%A1%9C-%EC%A4%84%EC%9D%B4%EA%B8%B0)
- [MySQL 성능 최적화: 비개발자를 위한 팁과 요령](https://wiki.yowu.dev/ko/Knowledge-base/mysql-for-planner-marketers/Learning/mysql-performance-optimization-tips-and-tricks-for-non-developers)
- [[MySQL] 쿼리 분석 / 속도 개선 / 최적화 / EXPLAIN](https://blog.naver.com/PostView.nhn?blogId=realmani&logNo=222030582194)
- [Mysql 쿼리최적화](https://yeongunheo.tistory.com/entry/Mysql-%EC%BF%BC%EB%A6%AC%EC%B5%9C%EC%A0%81%ED%99%94)
- [쿼리 튜닝을 통해 슬로우 쿼리 개선하기](https://medium.com/team-joon/%EC%BF%BC%EB%A6%AC-%ED%8A%9C%EB%8B%9D%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-52480d1cd602)
- [[Database] SQL을 최적화하려면 이렇게 해야 한다.](https://myallinone.tistory.com/entry/SQL%EC%9D%84-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%9D%B4%EB%A0%87%EA%B2%8C-%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
- [[MySQL] 순위 조회 쿼리 성능 개선하기 (인덱스, 실행계획)](https://cookie-dev.tistory.com/31)
- [Mysql 성능 조회 - Explain 실행 계획으로 쿼리 성능 최적화하기](https://thalals.tistory.com/349)
- [SQL 쿼리 튜닝하는 여러가지 방법](https://chung-develop.tistory.com/145)
- [적정 엔지니어링으로 검색 속도 10x 빠르게 만들기](https://engineering.ab180.co/stories/improve-performance-with-proper-engineering)
- [MySQL 쿼리 튜닝의 첫걸음](https://yozm.wishket.com/magazine/detail/2260/)
- [[MySQL/SpringDataJPA] 생애 첫 쿼리 튜닝을 통한 조회 성능을 개선](https://wimoney.tistory.com/entry/MySQLSpringDataJPA-%EC%83%9D%EC%95%A0-%EC%B2%AB-%EC%BF%BC%EB%A6%AC-%ED%8A%9C%EB%8B%9D%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%A1%B0%ED%9A%8C-%EC%84%B1%EB%8A%A5%EC%9D%84-%EA%B0%9C%EC%84%A0)
- [MySQL 쓰면서 하지 말아야 할 것 17가지](https://blog.lael.be/post/370)
- [MySQL의 Between 쿼리 개선하기](https://pjh3749.tistory.com/287)
- [SELECT 및 다른 명령문 최적화 하기](https://dataonair.or.kr/db-tech-reference/d-guide/dbms-2/?mod=document&uid=62469)
- [Mysql 성능개선 팁](https://epthffh.tistory.com/entry/Mysql-%EC%84%B1%EB%8A%A5%EA%B0%9C%EC%84%A0-%ED%8C%81)
- [MYSQL DELETE 시 속도 개선](https://ygdev84.tistory.com/21)
- [[MYSQL] 커버링 인덱스를 통한 쿼리 성능 개선](https://tipland.tistory.com/55)
- [쿼리 최적화: 빠른 쿼리를 위한 7가지 체크리스트 ✅](https://medium.com/watcha/%EC%BF%BC%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%B2%AB%EA%B1%B8%EC%9D%8C-%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-7%EA%B0%80%EC%A7%80-%EC%B2%B4%ED%81%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-bafec9d2c073)
- [MySQL 속도 개선 TIP](https://kimyhcj.tistory.com/entry/MySQL-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0-TIP)
- [[MYSQL] 쿼리속도가 현저하게 느릴때, 인덱스를 정상적으로 타고 있는지 궁금하다면 MYSQL - Explain ](https://episode1982.tistory.com/entry/%EC%BF%BC%EB%A6%AC%EC%86%8D%EB%8F%84%EA%B0%80-%ED%98%84%EC%A0%80%ED%95%98%EA%B2%8C-%EB%8A%90%EB%A6%B4%EB%95%8C-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EC%A0%95%EC%83%81%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%83%80%EA%B3%A0-%EC%9E%88%EB%8A%94%EC%A7%80-%EA%B6%81%EA%B8%88%ED%95%98%EB%8B%A4%EB%A9%B4-MYSQL-Explain)
- [[MySQL]데이터베이스 튜닝, 최적의 성능을 위한 5가지 핵심 팁](https://mooonstar.tistory.com/entry/MySQL%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%9C%EB%8B%9D-%EC%B5%9C%EC%A0%81%EC%9D%98-%EC%84%B1%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-5%EA%B0%80%EC%A7%80-%ED%95%B5%EC%8B%AC-%ED%8C%81)
- [[Mysql, Querydsl] 반정규화를 통한 조회 성능 개선 (트래픽 부하 테스트)](https://tjdtls690.github.io/studycontents/java/2023-11-03-select_perform_improve/)
- [[MySql] JOIN 속도를 빠르게! EXPLAIN, STRAIGHT_JOIN](https://marobiana.tistory.com/35)
- [[기술적 선택] 쿼리 성능 개선을 위한 INDEX 적용](https://baebalja.tistory.com/566)
- [MySQL - 쿼리 성능(실행 시간, CPU 사용량 등) 확인하는 방법 [Profiling]](https://www.codenary.co.kr/discovery/list?id=4547)