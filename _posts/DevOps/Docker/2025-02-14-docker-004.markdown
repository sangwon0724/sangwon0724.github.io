---
layout: post
title:  "도커 파일 (DockerFile)"
date:   2025-02-14 17:11:00 +0900
categories: Docker
tags: []
---

### 이미지는 누가 만든 것일까?

기본적으로 도커의 이미지는 도커 허브에서 다운받아서 사용한다.  
그러면 그 이미지는 누가 만드는 것일까?  
그리고 나만의 이미지를 만드려면 어떻게 해야할까?  
이 때 도커 파일을 사용하면 나만의 이미지를 만들 수 있다.

### 도커 파일(DockerFile)이란?

도커 이미지를 만들게 해주는 파일이다.

`FROM`, `COPY`, `ENTRYPOINT`, `RUN`, `WORKDIR`, `EXPOSE`같은 명령문 등을 통해 이미지를 만들 수 있다.

### 파일 생성하기

`Dockerfile`이라는 이름으로 파일을 만들면 된다.  
별도의 확장자 없이 파일명만 `Dockerfile`로 만들면 된다.  
인텔리제이나 VSCODE같은 IDE를 사용할 경우에 도커 아이콘이 노출되는 것을 확인할 수 있다.  
프로젝트 루트 폴더에 만들면 된다.

### FROM

베이스 이미지를 생성하는 역할을 한다.  
도커 컨테이너를 특정 이미지를 기반으로 세팅하기 위해 사용한다.

#### 문법

`FROM 이미지명:태그명`을 통해 작성한다.  
`docker pull` 명령문와 같다고 생각하면 된다.  
그래서 태그명 생략이 가능하며, 생략할 경우에는 해당 이미지의 최신 버전을 사용한다.

#### 예시

- `FROM openjdk:17-jdk`
- `FROM openjdk:23-ea-17-jdk`
- `FROM node`

### COPY

호스트 컴퓨터에 있는 파일을 복사해서 컨테이너로 전달하는 역할을 한다.

#### 문법

`COPY [호스트 컴퓨터에 있는 복사할 파일의 경로] [컨테이너에서 파일이 위치할 경로]`를 통해 작성한다.  
단일 파일만 복사하는 것도 가능하고, 폴더를 복사하는 것도 가능하다.  
그리고 호스트의 파일을 컨테이너 내부의 폴더에 복사하는 것도 가능하다.

#### 와일드카드

와일드카드를 통해 표현식을 통한 파일 및 폴더 복사가 가능하다.  
예를 들어 `*.txt`처럼 작성하면 모든 `.txt` 확장자를 가진 파일이 해당되고,  
`sam?le.txt`처럼 작성하면 `sample.txt`같은 파일이 해당된다.

#### 예시

- `COPY app.txt /app.txt`
- `COPY ./build/libs/*.jar app.jar`
- `COPY *.txt /text-files/`
- `COPY sam?le.txt /text-files/`

#### 주의사항

폴더를 복사할 때는 끝에 `/`를 붙여야 한다.  
만약 `/files`라는 경로에 복사하고 싶다면 `COPY xxx /files/`라고 작성해야 한다.

#### .dockerignore 파일

복사하는 파일이나 폴더 중에 일부는 제외하고 싶을 수도 있다.  
그럴 때는 `.dockerignore` 파일을 만들면 된다.  
`.gitignore`처럼 제외하고 싶은 파일명이나 폴더명 목록을 엔터로 구분해서 작성하면 된다.

### ENTRYPOINT

컨테이너가 생성되고 최초로 실행할 때 수행되는 명령문을 전달하는 역할을 한다.

#### 문법

`ENTRYPOINT [명령문...]`처럼 작성하면 된다.

#### 예시

- `ENTRYPOINT ["java","-jar","app.jar"]`
- `ENTRYPOINT ["node", "dist/main.js"]`

### RUN

이미지가 생성될 때 실행할 명령문을 전달하는 역할을 한다.  

#### 문법

`RUN [명령문]`처럼 작성하면 된다.  
명령문이 여러 개일 경우 `&&` 연산자를 통해 연결하면 된다.

#### 예시

- `RUN npm install`
- `RUN apt update && apt install -y git`

### WORKDIR

작업 디렉토리를 지정하는 역할을 한다.  
`RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD`같은 명령문들은  
기본적으로 해당 컨테이너의 루트 디렉토리에서 실행된다.  
특히 `COPY`나 `ADD`같은 명령문을 통한 파일 복사를 진행하면  
컨테이너 내부의 기존 파일들과 섞일 수도 있기 때문에  
`WORKDIR`을 통해 작업 디렉토리를 전환하는 것이 좋다.  
`WORKDIR`을 통해 작업 디렉토리를 전환하면 
`RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD`같은 명령문들을 실행했을 때  
해당 디렉토리를 기준으로 실행된다.

#### 문법

`WORKDIR [작업 디렉토리로 사용할 절대 경로]`처럼 작성하면 된다.

#### 예시

- `WORKDIR /usr/src/app`
- `WORKDIR /my-dir`

### EXPOSE

컨테이너 내부에서 어떤 포트에 프로그램이 실행되는지 문서화하는 역할을 한다.  
`docker run` 명령문의 `-p` 옵션같은 역할은 전혀 없다.  
그래서 명시를 하든 안 하든 컨테이나 동작에는 전혀 영향을 미치지 않는다.

#### 문법

`EXPOSE [포트 번호]`처럼 작성하면 된다.

#### 예시

- `EXPOSE 3000`

### 이미지 만들기

`docker build -t 이미지명` 명령문를 통해 이미지를 만들 수 있다.

### 컨테이너 디버깅

도커를 사용하면 대부분의 코드가 컨테이너 내부에서 동작한다.  
그래서 보통 내부 동작을 확인하기 위해서는 2가지 방법을 사용한다.

`docker logs` 명령문를 통해서 컨테이너 로그를 확인하거나,  
`docker exec -it` 명령문를 통해서 컨테이너 내부를 직접 확인한다.

다만 `docker exec -it`의 경우에는 실행 중인 컨테이너에서만 사용 가능한 명령문다.  
그래서 컨테이너가 종료되면 사용할 수가 없는데  
컨테이너는 그 특성 상 `docker stop`같은 명령문를 통해서 정지시키면  
바로 정지 상태로 바뀌어 버린다.

이를 방지하기 위해 `DockerFile`에는 종료를 유예시키는 명령문이 있다.  
`ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]`같이 명령문를 추가하면 컨테이너가 즉시 종료되는 것을 막을 수 있다.  
해당 명령문를 `DockerFile`에 추가하면 500초동안 `docker exec -it` 명령문를 통해서  
컨테이너 내부에 직접 들어가서 디버깅을 할 수 있다.

### 출처

[비전공자도 이해할 수 있는 Docker 입문/실전](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-docker-%EC%9E%85%EB%AC%B8-%EC%8B%A4%EC%A0%84)