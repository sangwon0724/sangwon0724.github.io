<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Boot 공부</title>
    <!-- code pretty print -->
    <link rel="stylesheet" href="./css/codePrettyPrint.css">
</head>
<body>
    <section id="swagger">
        <header class="note_title">Swagger</header>
        <ul>
            <li>Swagger
                <pre>
                    ● 개발한 Rest API를 편리하게 문서화해주는 프로젝트
                    ● 관리 및 제 3자의 사용자가 편리하게 호출해보고 테스트할수 있게 해준다.
                    ※ 주의점 : 운영환경과 같은 외부에 노출되면 안되는 곳에서 사용할땐 주의해야한다.
                </pre>
            </li>
            <li>설치 방법
                <pre>
                    ● pom.xml에 dependency 추가
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>io.springfox&lt;/groupId>
                                &lt;artifactId>springfox-boot-starter&lt;/artifactId>
                                &lt;version>3.0.0&lt;/version>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>Swagger 제공 어노테이션
                <pre>
                    ● @APi : 클래스를 스웨거의 리소스로 표시
                        ○ 사용 예시 )
                            @Api(tags = {"REST API CONTROLLER"}) //루트주소/swagger-ui/index.html에서 해당 컨르롤러 클래스의 이름이 REST API CONTROLLER로 보인다. 
                    ● @ApiOperation : 특정 경로의 오퍼레이션 HTTP 메소드 설명
                        ○ 사용 예시 )
                            @ApiOperation(value = "hello method", notes = "기본적인 인사 GET API")
                            //@ApiOperation 없는 경우 : 메소드명
                            //@ApiOperation 있는 경우 : hello method, note는 /swagger-ui/index.html에서 해당 메소드 클릭시 보이는 주석을 설정한다.
                    ● @ApiParam : 메소드의 파라미터에 대한 메타 데이터 설명 (Controller의 메소드의 파라미터에서 사용)
                        ○ 사용 예시 )
                            @ApiParam(value = "사용자 이름") String name
                            //@ApiParam이 없는 경우 : name - name
                            //@ApiParam이 있는 경우 : name - 사용자 이름
                    ● @ApiResponse : 메소드의 응답 지정
                        ○ 사용 예시 )
                            @ApiResponse(code = 404, message = "not found")
                    ● @ApiModelProperty : 모델의 속성 데이터를 설명 (VO의 필드에서 사용)
                        ○ 사용 예시 )
                            @ApiModelProperty(value = "사용자 이름", example = "steve")
                            //@ApiModelProperty이 없는 경우 : name - name
                            //@ApiModelProperty이 있는 경우 : name - 사용자 이름
                            //value : 해당 필드에 대한 설명
                            //example : /swagger-ui/index.html에서 해당 메소드의 Responses의 Example Value 항목에서 보일 예시 값
                            //required : 필수 여부
                    ● @ApiImplicitParam : 메소드 단위의 오퍼레이션 파라미터를 설명
                    ● @APiImplicitParams : @ApiImplicitParam의 배열을 지정
                        ○ @ApiImplicitParam와 @ApiImplicitParams의 예시 (Controller의 메소드 위에 명시)
                            @ApiImplicitParams({
                                @ApiImplicitParam(name="name", value="사용자 이름"),
                                @ApiImplicitParam(name="age", value="사용자 나이")
                            })
                            //name : 파라미터의 변수명을 의미
                            //value : 해당 파라미터에 대한 설명
                            //required : 필수 여부
                            //dataType : 해당 파라미터의 데이터 타입
                </pre>
            </li>
            <li>기본 사용법
                <pre>
                    1. 해당 프로젝트를 실행한다.
                    2. 브라우저를 키고 localhost:(해당 프로젝트의 서버포트)/swagger-ui/index.html를 입력하여 결과물을 확인한다.

                    ※ 예전에는 @SpringBootApplication Class에 @EnableSwagger2를 추가해야 했으나 현재는 추가하지 않아도 자동적으로 모든 컨트롤러에 Swagger가 적용된다. (일정 버전 이상부터)
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="thymeleaf">
        <header class="note_title">Thymeleaf</header>
        <ul>
            <li>Thymeleaf
                <pre>
                    ● MVC 패턴에 적합하게 설계된 Java 기반의 템플릿 엔진
                    ● 생성할 html 파일의 기본 경로 : src/main/resources/templates
                    ● html 파일의 html 태그에 xmlns:th="http://www.thymeleaf.org"를 추가해서 사용한다.
                </pre>
            </li>
            <li>설치방법
                <pre>
                    ● pom.xml에 dependency 추가
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>org.springframework.boot&lt;/groupId>
                                &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId>
                                &lt;version>2.3.4.RELEASE&lt;/version>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>외부 파일 연결
                <pre>
                    ● 기본 경로 : src/main/resources/static
                    ● 예시) &lt;link th:href="@{/css/index.css}" rel="stylesheet" type="text/css">
                </pre>
            </li>
            <li>데이터 연결하기
                <pre>
                    ● 기본 객체 선택 => th:object="객체"
                        예시)
                            <pre class="prettyprint lang-html">
                                &lt;table>
                                    &lt;tr th:object="${board}">
                                        &lt;td>&lt;span class="no" th:text="{board.no}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="title" th:text="{board.title}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="writer" th:text="{board.writer}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="signdate" th:text="${#temporals.format(board.signdate, 'yyyy-MM-dd HH:mm')}"></span></td>
                                    &lt;/tr>
                                &lt;/table>
                            </pre>

                    ● 반복문 => th:each="객체 : ${리스트}"
                        예시)
                            <pre class="prettyprint lang-html">
                                &lt;table>
                                    &lt;tr th:each="board : ${boardList}">
                                        &lt;!-- 인덱스 값 가져오기 ▼ -->
                                        &lt;!--&lt;td>&lt;span class="no" th:text="{iterState.index}">&lt;/span>&lt;/td>-->
                                        &lt;td>&lt;span class="no" th:text="{board.no}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="title" th:text="{board.title}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="writer" th:text="{board.writer}">&lt;/span>&lt;/td>
                                        &lt;td>&lt;span class="signdate" th:text="${#temporals.format(board.signdate, 'yyyy-MM-dd HH:mm')}"></span></td>
                                    &lt;/tr>
                                &lt;/table>
                            </pre>

                    ● 조건문 - (if-unless) => th:if="${비교대상} [조건] [비교값]"
                        예시)
                        <pre class="prettyprint lang-html">
                            &lt;table>
                                &lt;tr th:each="board : ${boardList}" th:if="${iterState.count} % 2 != 0">
                                    &lt;td>&lt;span class="no" th:text="{board.no}">&lt;/span>&lt;/td>
                                    &lt;td>&lt;span class="title" th:text="{board.title}">&lt;/span>&lt;/td>
                                    &lt;td>&lt;span class="writer" th:text="{board.writer}">&lt;/span>&lt;/td>
                                    &lt;td>&lt;span class="signdate" th:text="${#temporals.format(board.signdate, 'yyyy-MM-dd HH:mm')}"></span></td>
                                &lt;/tr>
                            &lt;/table>
                        </pre>

                    ● 조건문 - (switch-case) => th:switch="조건대상" + th:case=조건값"
                        예시)
                            <pre class="prettyprint lang-html">
                                &lt;div th:switch="${user.grade}">
                                    &lt;p th:case="'normal'">일반 회원&lt;/p>
                                    &lt;p th:case="'vip'">VIP 회원&lt;/p>
                                &lt;/div>
                            </pre>

                    ● 값 설정하기
                        ○ input 태그의 값 지정하기 => th:value
                            예시)
                                &lt;input type="text" id="nickname" th:value="${userInfo.nickname}"/>
                        ○ 속성 값 지정하기 => th:attr
                            예시)
                                &lt;input type="radio" id="YesOrNo" th:attr="checked=${YesOrNo}"/>
                                ※ 실제로 존재하지 않는 임의의 속성을 만들고 싶을 때 사용하는 것이 좋다.
                                ※ action이나 checked같은 속성은 th:action이나 th:checked를 사용할수 있다.
                        ○ 로컬 변수 선언하기 =>  th:with
                            예시)
                                &lt;div th:with="grade=${info.grade},size=${info.size}">&lt;/div>

                    ※ html 태그 없이 조건문을 사용하고 싶은 경우에는 &lt;th:block> 태그를 사용하면 된다.
                    ※ th:text와 th:utext의 차이
                        ▶ th:text → 태그 안의 텍스트 (태그 형식의 텍스트도 일반 텍스트로 취급)
                        ▶ th:utext → 태그 형식의 텍스트가 들어오면 태그로 인식한다.
                </pre>
            </li>
            <li>페이지 include 하기
                <pre>
                    1. include 페이지의 영역에 th:fragment="고유영역명"을 추가한다. (= 조각 생성)
                    2. include 페이지를 적용시킬 페이지에서 각 영역에 th:replace="[파일 경로 :: 고유영역명]"을 추가한다.

                    예시)
                        1. src/main/resources/static/include 폴더의 common.html에서
                           다른 페이지들에 적용시킬 header와 footer 영역을 만든 뒤에
                           각각 th:fragment="header"와 th:fragment="footer"를 추가한다.
                        2. index.html에 가서 include 시킬 임시 영역을 만든다음에
                           각각 th:replace="[include/common::header]"와 th:replace="[include/common::footer]"를 추가한다.
                           => include/common은 include 폴더 안에 있는 common.html을 의미한다.
                </pre>
            </li>
            <li>요소 삭제하기
                <pre>
                    ● 삭제하고 싶은 내용이 있는 태그에 th:remove="속성값"을 추가한다.
                        ○ all: th:remove가 선언된 태그와 그 자식 태그들도 모두 삭제한다.
                        ○ body: th:remove가 선언된 태그는 그대로 두고 자식 태그들만 삭제한다.
                        ○ tag: th:remove가 선언된 태그만 삭제하고 자식 태그들은 그대로 둔다.
                        ○ all-but-first: 첫 번째 자식 태그만 두고 나머지 자식 태그는 모두 삭제한다.
                        ○ none: 아무것도 삭제하지 않고 그대로 둔다. (조건 표현식을 사용하여 조건에 따라 삭제를 할지 말지 결정할 때 사용)
                </pre>
            </li>
            <li>페이지 하이퍼링크 생성하기 (th:href="@{경로}")
                <pre>
                    ● 단순한 URL
                        예시 ) &lt;a th:href="@{/main}">메인 화면 이동&lt;/a>

                    ● 쿼리 파라미터 → () 에 있는 부분은 쿼리 파라미터로 처리
                        예시 ) &lt;a th:href="@{/main(paramA=${paramA}, paramB=${paramB})}">메인 화면 이동&lt;/a>
                                => /main?paramA=dataA&paramB=dataB
                    
                    ● 경로 변수 → URL 경로상에 변수가 있으면 () 부분은 경로 변수로 처리
                        예시 ) &lt;a th:href="@{/main/{param1}/{param2}(param1=${param1}, param2=${param2}))}">메인 화면 이동&lt;/a>
                                => /main/dataA/dataB

                    ※ 쿼리 파라미터와 경로 변수를 동시에 사용할 수도 있다.
                </pre>
            </li>
            <li>타임리프의 유틸
                <pre>
                    ● #message : 메시지, 국제화 처리
                    ● #uris : URI 이스케이프 지원
                    ● #dates : java.util.Date 서식 지원
                    ● #calendars : java.util.Calendar 서식 지원
                    ● #temporals : java.time.LocalDateTime 서식 지원 (Java 8, 타임리프 권장)
                        ○ ${#temporals.format(형식을 지정할 LocalDateTime형의 데이터, 형식)}
                    ● #numbers : 숫자 서식 지원
                    ● #strings : 문자 관련 편의 기능
                    ● #objects : 객체 관련 기능 제공
                    ● #bools : boolean 관련 기능 제공
                    ● #arrays : 배열 관련 기능 제공
                    ● #lists , #sets , #maps : 컬렉션 관련 기능 제공
                    ● #ids : 아이디 처리 관련 기능 제공
            </li>
        </ul>
    </section>

    <br>

    <section id="ObjectMapper">
        <header class="note_title">ObjectMapper</header>
        <ul>
            <li>ObjectMapper
                <pre>
                    ● Java 객체를 Json으로 직렬화 하거나 또는 Json 데이터를 Java 객체에 역직렬화 하는 기능을 수행하는 클래스
                    ● 최근 API 서비스가 아니더라도 복잡한 구조의 데이터를 쉽게 서로 주고 받을 수 있게 하기 위해
                      View 영역과 백엔드가 통신을 할 때 Json을 많이 이용하기 때문에 많이 사용하게 된 클래스
                </pre>
            </li>
            <li>사용 조건 (pom.xml의 dependency)
                <pre>
                    ● Spring의 경우
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>
                                &lt;artifactId>jackson-databind&lt;/artifactId>
                                &lt;version>2.9.8&lt;/version>
                            &lt;/dependency>
                        </pre>
                    ● Spring Boot의 경우
                        <pre class="prettyprint lang-xml">
                            &lt;dependency>
                                &lt;groupId>org.springframework.boot&lt;/groupId>
                                &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
                            &lt;/dependency>
                        </pre>
                </pre>
            </li>
            <li>기본 사용 방법
                <pre>
                    ※ ObjectMapper objectMapper = new ObjectMapper();

                    ● Java Object → Json
                        UserVO user = UserVO.builder().name("HongGilDong").age(25).email("hong@naver.com").birthday("19970229").phoneNumber("0001112222").build();
                        String javaObjectToJson = objectMapper.writeValueAsString(user);
                    ● Json → Java Object
                        String jsonString = "{\"name\":\"jsonString\",\"age\":25,\"email\":\"jsonString@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        UserVO jsonToJavaObject = objectMapper.readValue(jsonString, UserVO.class);
                    ● JSON 배열을 Java List에 매핑하기
                        String jsonStringA = "{\"name\":\"jsonStringA\",\"age\":25,\"email\":\"jsonStringA@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        String jsonStringB = "{\"name\":\"jsonStringB\",\"age\":25,\"email\":\"jsonStringB@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        String jsonArray = "["+jsonStringA+","+jsonStringB+"]";
                        List&lt;UserVO> users = objectMapper.readValue(jsonArray, new TypeReference&lt;List&lt;UserVO>>(){});
                    ● JSON 데이터를 Map에 매핑하기
                        String jsonStringForMap = "{\"name\":\"jsonStringForMap\",\"age\":25,\"email\":\"jsonStringForMap@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        HashMap&lt;String, Object> map = objectMapper.readValue(jsonStringForMap, new TypeReference&lt;HashMap&lt;String,Object>>(){});

                    ※ 예외사항 (@Builder 어노테이션을 사용하는 경우의 VO)
                        예시)
                            <pre class="prettyprint lang-java">
                                @Getter
                                @Setter
                                @Builder(builderClassName = "UserVOBuilder", toBuilder = true)
                                @JsonDeserialize(builder = UserVO.UserVOBuilder.class)
                                public class UserVO {
                                    private String name; //이름
                                    private int age; //나이
                                    private String email; //이메일
                                    private String phoneNumber; //핸드폰번호
                                    private String birthday; //생년월일
                                    
                                    @JsonPOJOBuilder(withPrefix = "") public static class UserVOBuilder { 
                                        
                                    }
                                }
                            </pre>
                </pre>
            </li>
            <li>추가 사용 방법
                <pre>
                    ※ ObjectMapper objectMapper = new ObjectMapper();

                    ● 역직렬화 실행시 존재하지 않는 필드 무시 설정
                        예시)
                            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 없는 필드로 인한 오류 무시
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="modelMapper">
        <header class="note_title">ModelMapper</header>
        <ul>
            <li>MbjectMapper
                <pre>
                    ● xxx
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="responseEntity">
        <header class="note_title">ResponseEntity</header>
        <ul>
            <li>ResponseEntity Class
                <pre>
                    ● 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스
                    ● HttpEntity를 상속받아서 만들어진 클래스 (HttpEntity = HttpHeaders + HttpBody)
                    ● ResponseEntity = HttpStatus + HttpHeaders + HttpBody + a
                        ○ HttpHeaders : HTTP의 request 또는 response에 대한 부가적인 정보 (예시 : 전달받은 데이터 형식)
                        ○ HttpBody : HTTP의 request 또는 response가 전송하는 데이터 (본문), 존재하지 않는 경우도 있다. (예시 : GET 방식)
                        ○ HttpStatus : 클라이언트의 요청이 성공적으로 처리되었는지 상태를 알려주는 고유의 값 (예시 : 405)
                    ● ResponseEntity 객체가 반환되면 Json이나 Xml 등 다른 형식으로 직렬화가 된다.
                </pre>
            </li>
            <li>전달 형식
                <pre>
                    ● 1번 형태 (한 번에 생성하는 방식)
                        ○ 1-1
                            return new ResponseEntity&lt;반환할 타입>(전달할 body, 전달할 header, HttpStatus.코드명);
                            //예시 : return new ResponseEntity&lt;UserVO>(user, headers , HttpStatus.BAD_REQUEST);
                        ○ 1-2
                            return new ResponseEntity&lt;반환할 타입>(전달할 body, 전달할 header, HttpStatus.valueOf(코드값));
                            //예시 : return new ResponseEntity&lt;UserVO>(user, headers , HttpStatus.valueOf(400));
                    ● 2번 형태 (오류메소드를 사용하여 바로 반환하는 방식)
                        ○ 2-1
                            return ResponseEntity.오류메소드명(객체명); //매개변수가 있는 ok 메소드는 ResponseEntity 형태로 return
                            //예시 : return ResponseEntity.badRequest(user);
                        ○ 2-2
                            return ResponseEntity.오류메소드명().build(); //매개변수가 없는 ok 메소드는 BodyBuilder 형태이기 때문에 build()를 통해서 ResponseEntity 변환 후 return
                            //예시 : return ResponseEntity.ok().build();
                    ● 3번 형태 (각각의 파라미터를 설정해서 개별 설정하는 방식)
                        ○ 사용 예시 )
                            <pre class="prettyprint lang-java">
                                HttpHeaders HttpHeaders변수명 = new HttpHeaders(); //org.springframework.http.HttpHeaders
                                HttpHeaders변수명.set("속성명", "값");
    
                                VO클래스 vo변수명 = UserVO.builder().필드명("값").build();
                            
                                return ResponseEntity.오류메소드명()
                                        .headers(HttpHeaders변수명)
                                        .body(vo변수명)
                                        .status(HttpStatus.코드명);
                            </pre>
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="annotation">
        <header class="note_title">어노테이션 목록</header>
        <ul>
            <li>목록
                <pre>
                    ● @SpringBootApplication
                    ● @JsonProperty
                    ● @JsonNaming
                    ● @JsonInclude
                </pre>
            </li>
            <li>스프링 부트
                <pre>
                    ● @SpringBootApplication : 해당 클래스를 Spring Boot Application으로 설정
                </pre>
            </li>
            <li>컨트롤러 관련 어노테이션
                <pre>
                    ● @RestController
                        ○ 정의 : 해당 클래스를 REST API를 제공하는 컨트롤러로 설정
                        ○ 요약 : @Controller + @ResponseBody
                        ※ 주의점 :
                            @RestController를 붙이게 되면 해당 컨트롤러는 view 페이지를 반환하는게 아닌 응답본문 객체를 반환하는 것이기 때문에
                            Ajax같은 기능에 대한 메소드들이 모여있는 클래스에서 사용하는 것이 좋다.

                    ● @GetMapping : Http Get Method URL 주소 매핑
                    ● @PostMapping : Http Post Method URL 주소 매핑
                    ● @PutMapping : Http Put Method URL 주소 매핑
                    ● @DeleteMapping : Http Delete Method URL 주소 매핑

                    ● @Valid : POJO Java class의 검증
                </pre>
            </li>
            <li>Lombok 어노테이션
                <pre>
                    ● @Data : 종합 선물 세트
                        ○ @Data
                            = @toString  + @EqualsAndHashCode
                            + @Getter  + @Setter
                            + @NoArgsConstructor + @RequiredArgsConstructor  + @AllArgsConstructor
                        ○ 효과가 너무 강하여 왠만하면 @Data 어노테이션보다는 필요한 어노테이션만 따로 설정하는 것이 좋다.

                    ● @Getter : getter 메소드를 자동으로 만들어준다. 
                    ● @Setter : setter 메소드를 자동으로 만들어준다.

                    ● @Value : 불변하는 특성을 가진 객체를 만드려고 할 때 사용한다.

                    ● @NoArgsConstructor : 파라미터가 없는 생성자를 생성해준다.
                        ○ final이 붙어있는 경우에는 필드를 초기화 할 수 없기 때문에 생성자를 만들 수가 없어서 에러가 발생한다.
                        ○ final이 붙어있는 경우에는 @NoArgsConstructor(force = true) 옵션을 이용해서 강체로 초기화시켜서 생성자를 만드는 방법을 사용한다.
                        ○ @NonNull 같이 필드에 제약조건이 설정되어 있는 경우, 생성자 내에 null-check 로직이 생성되지 않는다.
                    ● @RequiredArgsConstructor : 추가 작업을 필요로 하는 필드에 대한 생성자를 생성
                        ○ 초기화 되지 않은 모든 final 필드와 @NonNull같은 validator로 마크돼있는 모든 필드들에 대한 생성자를 자동으로 생성해준다.
                        ○ validator 어노테이션이 붙어있는 필드에 대하여 만들어진 생성자는 자동적으로 해당 어노테이션에 대한 검증요소가 추가된다.
                    ● @AllArgsConstructor : 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
                        ○ @NoArgsConstructor + @RequiredArgsConstructor
                    ● @Builder : 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
                        ○ @AllArgsConstructor 또는 @RequiredArgsConstructor
                        ○ @Builder 이외의 생성자 어노테이션들은 필드를 선언한 순서대로 생성자의 파라미터를 만들기 때문에
                          만약 VO Class에서 두 필드의 선언 순서를 바꿨는데 두 필드가 자료형까지 같다면 오류가 발생하지 않기 때문에
                          추후에 문제가 발생해도 모를 확률이 크기때문에 @Builder를 사용하는 것이 좋다.
                        ○ 기본 사용 예시
                            <pre class="prettyprint lang-java">
                                UserVO tempUser
                                = UserVO.builder()
                                    .name("홍길동")
                                    .age(25)
                                    .email("hong@naver.com")
                                    .phoneNumber("0001112222")
                                    .birthday("19970229")
                                    .build();
                            </pre>
                        ○ @Builder(toBuilder = true) 사용 예시 : builder 패턴으로 생성된 객체의 일부 값을 변경한 새로운 객체 생성
                            <pre class="prettyprint lang-java">
                                UserVO userA
                                = UserVO.builder()
                                    .name("A")
                                    .age(25)
                                    .email("hong@naver.com")
                                    .phoneNumber("0001112222")
                                    .birthday("19970229")
                                    .build();

                                    //userA에서 name/age 값만 변경된 새로운 객체를 생성 
                                    BuilderVO b2 = b.toBuilder().name("B").age(24).build();
                            </pre>
                        ○ @Builder.Default 사용 예시 :
                            <pre class="prettyprint lang-java">
                                private String name; //기본 값 null
                                @Builder.Default private String job="programmer"; //기본 값 부여
                            </pre>
                        ○ @Singular 옵션 사용 예시 :
                            <pre class="prettyprint lang-java">
                                //vo
                                @Singular("hobbyList") private List&lt;String> hobbyList;
                                //생성 영역
                                UserVO userC
                                = UserVO..builder() .hobbyList("game") .hobbyList("read book") .hobbyList("listen music") .build();
                            </pre>


                    ● @ToString : 해당 VO Class의 모든 필드를 출력하는 toString 메소드를 생성한다.
                        ○ includeFieldNames 옵션 : includeFieldNames=false 옵션을 사용하면 필드의 이름을 출력하지 않는다.
                        ○ exclude 옵션 : exclude="필드명" 옵션을 사용하면 해당 필드를 제외한다. 여러개면 {} 안에 명시
                            ※ ToString에서 제외하고 싶은 필드에 직접 @ToString.Exclude을 추가해도 된다.
                        ○ of 옵션 : of={"필드1", "필드2", ...} 옵션을 사용하면 특정 필드를 포함하게 한다.
                        ○ callSuper 옵션 : callSuper=true 옵션을 사용하면 부모 클래스의 toString()을 호출한다.
                    ● @EqualsAndHashCode - hashcode와 equals 메소드를 생성한다.
                        ○ 불변 클래스를 제외하고는 아무 파라미터 없는 @EqualsAndHashCode 어노테이션은 사용하지 않는 것이 좋다.
                        ○ 항상 @EqualsAndHashCode(of={“필드명시”}) 형태로 동등성 비교에 필요한 필드를 명시하는 형태로 사용한다.
                        ○ equals :  두 객체의 내용이 같은지, 동등성(equality) 를 비교하는 연산자
                        ○ hashCode : 두 객체가 같은 객체인지, 동일성(identity) 를 비교하는 연산자
                        ○ callSuper 옵션
                            ▶ callSuper=true : 부모 클래스 필드 값들도 동일한지 체크
                            ▶ callSuper=false (기본값) : 자신 클래스의 필드 값만 체크
                    ● @Log / @Slf4j (★) / @Log4j2 : log 기능을 바로 사용해줄 수 있게 해준다.
                    ● @NonNull : null 값 체크
                    ● @Cleanup : I/O 작업이나 JDBC 작업시 try-catch-finally문의 finally에서 close()를 사용해야 하던 번거로움을 줄여준다.
                        예시) @Cleanup Connection con = DriverManager.getConnection(url, user, password);
                    ● @SneakyThrows(예외오류명.class) : throws나 try-catch문의 catch를 통한 번거로운 예외 처리 생략가능
                    ● @Synchronized : 동기화

                    ※ Lombok 설치 방법
                        1. pom.xml에 dependency 추가
                            <pre class="prettyprint lang-xml">
                                &lt;dependency>
                                    &lt;groupId>org.projectlombok&lt;/groupId>
                                    &lt;artifactId>lombok&lt;/artifactId>
                                    &lt;version>1.18.16&lt;/version>
                                    &lt;scope>provided&lt;/scope>
                                &lt;/dependency>
                            </pre>
                        2-A-1. cmd를 켜서 cd C:\Users\사용자명\.m2\repository\org\projectlombok\lombok\lombok버전 실행
                        2-A-2. java -jar lombok.jar 실행 (버전이 있는 경우 java -jar lombok-1.18.16.jar)
                        2-B-1. 파일 탐색기를 열고 C:\Users\사용자명\.m2\repository\org\projectlombok\lombok\lombok로 이동
                        2-B-2. lombok.jar 파일 실행
                        3. IDEs 목록에 사용하는 STS(eclipse)를 선택 (안 보이면 Specify location 버튼으로 찾기)
                        4. Install / Update 클릭
                        5. Install Successful이 출력되면 성공 (Quit Installer는 단순 종료 버튼)

                    ※ Lombok 어노테이션 추가 위치
                        ● 클래스 위
                        ● 필드 위

                    ※ @Getter / @Setter에 필드를 포함시키지 않는 방법
                        ● @Geeter(AccessLevel.None)
                        ● @Setter(AccessLevel.None)

                    ※ 생성자 어노테이션을 고유 이름으로 만들기
                       1. 해당 VO Class에 생성자 어노테이션을 추가한다.
                       2. 해당 어노테이션에 staticName="원하는 이름" 옵션을 추가한다.
                       3. 해당 Class에 대한 생성자는 private로 만들어진다.
                       4. private로 만들어진 생성자를 return 시키는 public static 생성자가 만들어진다. (생성자명은 옵션에 명시한 이름)

                    ※ 주의점
                        ● static 필드에도 @Getter / @Setter 적용이 가능하다.
                        ● enum에도 @Getter를 사용할 수 있다.
                        ● enum에는 @Setter를 사용할 수 없다.
                        ● 생성자 어노테이션에서 static 필드는 제외된다.
                        ● 생성자 어노테이션 사용 시 생성자의 파라미터의 순서는 해당 VO Class에서 필드를 선언한 순서와 같다. (주의 필요)
                        ● 생성자 어노테이션 사용시 기본값은 public이지만 필요로 따라서 접근 제한자를 설정해야 한다.
                        ● 생성자 어노테이션도 (access =AccessLevel.PROTECTED)처럼 기본 접근 제한자를 선택할 수 있는 옵션이 존재한다.
                        ● 왜인지는 모르겠는데 @Builder를 사용할 때 커스텀 어노테이션이 있으니까 오류가 생긴다.
                </pre>
            </li>
            <li>Custom Annotation
                <pre>
                   1. 어노테이션용 패키지를 만든다.
                   2. 해당 패키지에서 어노테이션 파일을 만든다. (New에 보면 어노테이션이 있다.)
                   3. 어노테이션 제작 시 필요한 항목들을 선택해서 만들거나 아니면 아래의 기본적인 값들을 복사 및 붙여넣기 한다.
                        기초 import 목록 )
                            <pre class="prettyprint lang-java">
                                import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
                                import static java.lang.annotation.ElementType.CONSTRUCTOR;
                                import static java.lang.annotation.ElementType.FIELD;
                                import static java.lang.annotation.ElementType.METHOD;
                                import static java.lang.annotation.ElementType.PARAMETER;
                                import static java.lang.annotation.ElementType.TYPE_USE;
                                import static java.lang.annotation.RetentionPolicy.RUNTIME;
                                
                                import java.lang.annotation.Documented;
                                import java.lang.annotation.Retention;
                                import java.lang.annotation.Target;
                                
                                import javax.validation.Constraint;
                                import javax.validation.Payload;
                            </pre>
                        기초 어노테이션 목록 )
                            <pre class="prettyprint lang-java">
                                @Documented
                                @Constraint(validatedBy = { })
                                @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
                                @Retention(RUNTIME)
                            </pre>
                        기초 속성 목록 )
                            <pre class="prettyprint lang-java">
                                String message() default "{javax.validation.constraints.Email.message}";
                                Class&lt;?>[] groups() default { };
                                Class&lt;? extends Payload>[] payload() default { };
                                String regexp() default ".*";
                            </pre>
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="study_api_integration">
        <header class="note_title">API 연동하기</header>
        <ul>
            <li>네이버 API
                <pre>
                    1. 네이버 메인 최하단의 "Developers" 메뉴 목록에서 "네이버 개발자" 센터 메뉴 클릭하기
                    2. 최상단의 "Application" 메뉴의 "애플리케이션 등록" 메뉴를 클릭한다.
                    3. 각 항목들을 설정하고 등록하기 버튼을 누른다.
                    4. 각 API의 가이드 문서를 보고 사용하면 된다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="reference">
        <header class="note_title">참조 목록</header>
        <ul>
            <li>Talend API Tester
                <pre>
                    ● 요청에 대한 테스트를 진행할 수 있는 크롬 앱
                    ● 크롬 앱스토어에서 설치 가능
                    ● 비슷한 프로그램 : 포스트맨
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="xxx">
        <header class="note_title">xxx</header>
        <ul>
            <li>xxx
                <pre>
                    ● xxx
                </pre>
            </li>
        </ul>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu" onchange="move_section()">
                <option value="intro">스프링 부트</option>
                <option value="validation">유효성 검사</option>
                <option value="exception">예외 처리</option>
                <option value="filter">필터</option>
                <option value="interceptor">인터셉터</option>
                <option value="async">비동기 처리</option>
                <option value="serverToServer">Server To Server</option>
                <option value="JUnit">JUnit</option>
                <option value="swagger">Swagger</option>
                <option value="thymeleaf">Thymeleaf</option>
                <option value="ObjectMapper">ObjectMapper</option>
                <option value="modelMapper">ModelMapper</option>
                <option value="responseEntity">ResponseEntity</option>
                <option value="annotation">어노테이션 목록</option>
                <option value="study_api_integration">API 연동하기</option>
                <option value="reference">참조 목록</option>
            </select>
        </section>
    </div>

    <!-- 모달 영역 시작 -->
    <div id="xxx" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <span class="modal_title">xxx</span>
            <div class="modal_content">
                <p style="margin-left: 30px;">
                    xxx
                </p>
            </div>
        </div>
    </div>
    <!-- 모달 영역 종료 -->

    <!--code pretty print -->
    <script src ="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

    <script>
        prettyPrint();
    </script>
</body>
</html>